<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<title>Node.js的Buffer那些你可能不知道的用法 - 早起搬砖 morning.work</title>
<style>
body {
  font-family: "Segoe UI", "Lucida Grande", Helvetica, Arial, "Microsoft YaHei", FreeSans, Arimo, "Droid Sans","wenquanyi micro hei","Hiragino Sans GB", "Hiragino Sans GB W3", Arial, sans-serif;
  width: 92%;
  max-width: 800px;
  margin: auto;
  font-weight: 400;
  color: rgba(0, 0, 0, 0.8);
  -webkit-font-smoothing: antialiased;
  word-break: break-word;
  font-size: 100%;
  line-height: 1.6;
}
#ds-thread {
  margin-top: 100px;
}
blockquote {
  font-size: 14px;
  color: rgba(0, 0, 0, 0.6);
  margin: 16px 24px;
}
code {
  padding: 0 6px;
  font-size: 0.875em;
  word-break: break-word;
  color: #c7254e;
  background-color: #f7f7f8;
  font-family: Consolas,Menlo,Monaco,"Courier New",monospace;
  font-weight: 400;
  text-rendering: optimizeSpeed;
  border-radius: 3px;
}
pre {
  line-height: 1.45;
  padding: 16px;
  background-color: #f7f7f8;
  border-radius: 3px;
}
pre code {
  padding: 0;
  color: rgba(0,0,0,.9);
}
h2 {
  border-bottom: 1px solid #CCC;
  margin-top: 32px;
}
a {
  color: #008E59;
  text-decoration: none;
}
a:hover {
  color: #B60000;
}
hr {
  border: none;
  border-bottom: 2px solid #CCC;
  margin: 20px 0 40px 0;
}
table {
  max-width: 100%;
  background-color: transparent;
  border-collapse: collapse;
  border-spacing: 0;
}
td, th {
  border: 1px solid #CCC;
  padding: 4px 16px;
}
#nav {
  border-bottom: 2px solid #eee;
  font-size: 18px;
}
#license {
  font-size: 14px;
  background-color: #f7f7f8;
  padding: 16px 6px;
}
#content {
  min-height: 200px;
}
#content img {
  display: block;
  max-width: 100%;
  margin: auto;
}
li > p {
  margin-top: 5px;
  margin-bottom: 0.4em;
}
</style>
</head>
<body>
  <nav id="nav">
    <a href="http://morning.work">早起搬砖 morning.work</a>
  </nav>

  <h1>Node.js的Buffer那些你可能不知道的用法</h1>
  <article id="content">
    <p><h3>目录</h3><ul><ul><li><a href="#_4">前言</a></li><li><a href="#_113">操作结构化数据</a></li><li><a href="#leiproto_213">lei-proto模块介绍</a></li><li><a href="#_266">扩展阅读</a></li></ul></ul></p>
<h2><a id="_4"></a>前言</h2>
<p>在大多数介绍Buffer的文章中，主要是围绕数据拼接和内存分配这两方面的。比如我们使用<code>fs</code>模块来读取文件内容的时候，返回的就是一个Buffer：</p>
<pre><code class="prettyprint javascript">fs.readFile('filename', function (err, buf) {
  // &lt;Buffer 2f 2a 2a 0a 20 2a 20 53 75 ... &gt;
});
</code></pre>
<p>在使用<code>net</code>或<code>http</code>模块来接收网络数据时，<code>data</code>事件的参数也是一个Buffer，这时我们还需要使用<code>Buffer.concat()</code>来做数据拼接：</p>
<pre><code class="prettyprint javascript">var bufs = [];
conn.on('data', function (buf) {
  bufs.push(buf);
});
conn.on('end', function () {
  // 接收数据结束后，拼接所有收到的Buffer对象
  var buf = Buffer.concat(bufs);
});
</code></pre>
<p>还可以利用<code>Buffer.toString()</code>来做转换<code>base64</code>或十六进制字符的转换，比如：</p>
<pre><code class="prettyprint javascript">console.log(new Buffer('hello, world!').toString('base64'));
// 转换成base64字符串：aGVsbG8sIHdvcmxkIQ==

console.log(new Buffer('aGVsbG8sIHdvcmxkIQ==', 'base64').toString());
// 还原base64字符串：hello, world!

console.log(new Buffer('hello, world!').toString('hex'));
// 转换成十六进制字符串：68656c6c6f2c20776f726c6421

console.log(new Buffer('68656c6c6f2c20776f726c6421', 'hex').toString());
// 还原十六进制字符串：hello, world!
</code></pre>
<p>一般情况下，单个Node.js进程是有最大内存限制的，以下是来自官方文档中的说明：</p>
<blockquote>
<p><a href="https://github.com/nodejs/node-v0.x-archive/wiki/FAQ#what-is-the-memory-limit-on-a-node-process">What is the memory limit on a node process?</a></p>
<p>Currently, by default v8 has a memory limit of 512MB on 32-bit systems, and 1.4GB on 64-bit systems. The limit can be raised by setting --max_old_space_size to a maximum of ~1024 (~1 GB) (32-bit) and ~4096 (~4GB) (64-bit), but it is recommended that you split your single process into several workers if you are hitting memory limits.</p>
</blockquote>
<p>由于Buffer对象占用的内存空间是不计算在Node.js进程内存空间限制上的，因此，我们也常常会使用Buffer来存储需要占用大量内存的数据：</p>
<pre><code class="prettyprint javascript">// 分配一个2G-1字节的数据
// 单次分配内存超过此值会抛出异常 RangeError: Invalid typed array length
var buf = new Buffer(1024 * 1024 * 1024 - 1);
</code></pre>
<p>以上便是Buffer的几种常见用法。然而，阅读Buffer的API文档时，我们会发现更多的是<code>readXXX()</code>和<code>writeXXX()</code>开头的API，具体如下：</p>
<ul>
<li>buf.readUIntLE(offset, byteLength[, noAssert])</li>
<li>buf.readUIntBE(offset, byteLength[, noAssert])</li>
<li>buf.readIntLE(offset, byteLength[, noAssert])</li>
<li>buf.readIntBE(offset, byteLength[, noAssert])</li>
<li>buf.readUInt8(offset[, noAssert])</li>
<li>buf.readUInt16LE(offset[, noAssert])</li>
<li>buf.readUInt16BE(offset[, noAssert])</li>
<li>buf.readUInt32LE(offset[, noAssert])</li>
<li>buf.readUInt32BE(offset[, noAssert])</li>
<li>buf.readInt8(offset[, noAssert])</li>
<li>buf.readInt16LE(offset[, noAssert])</li>
<li>buf.readInt16BE(offset[, noAssert])</li>
<li>buf.readInt32LE(offset[, noAssert])</li>
<li>buf.readInt32BE(offset[, noAssert])</li>
<li>buf.readFloatLE(offset[, noAssert])</li>
<li>buf.readFloatBE(offset[, noAssert])</li>
<li>buf.readDoubleLE(offset[, noAssert])</li>
<li>buf.readDoubleBE(offset[, noAssert])</li>
<li>buf.write(string[, offset][, length][, encoding])</li>
<li>buf.writeUIntLE(value, offset, byteLength[, noAssert])</li>
<li>buf.writeUIntBE(value, offset, byteLength[, noAssert])</li>
<li>buf.writeIntLE(value, offset, byteLength[, noAssert])</li>
<li>buf.writeIntBE(value, offset, byteLength[, noAssert])</li>
<li>buf.writeUInt8(value, offset[, noAssert])</li>
<li>buf.writeUInt16LE(value, offset[, noAssert])</li>
<li>buf.writeUInt16BE(value, offset[, noAssert])</li>
<li>buf.writeUInt32LE(value, offset[, noAssert])</li>
<li>buf.writeUInt32BE(value, offset[, noAssert])</li>
<li>buf.writeInt8(value, offset[, noAssert])</li>
<li>buf.writeInt16LE(value, offset[, noAssert])</li>
<li>buf.writeInt16BE(value, offset[, noAssert])</li>
<li>buf.writeInt32LE(value, offset[, noAssert])</li>
<li>buf.writeInt32BE(value, offset[, noAssert])</li>
<li>buf.writeFloatLE(value, offset[, noAssert])</li>
<li>buf.writeFloatBE(value, offset[, noAssert])</li>
<li>buf.writeDoubleLE(value, offset[, noAssert])</li>
<li>buf.writeDoubleBE(value, offset[, noAssert])</li>
</ul>
<p>这些API为在Node.js中操作数据提供了极大的便利。假设我们要将一个整形数值存储到文件中，比如当前时间戳为<code>1447656645380</code>，如果将其当作一个字符串存储时，需要占用11字节的空间，而将其转换为二进制存储时仅需6字节空间即可：</p>
<pre><code class="prettyprint javascript">var buf = new Buffer(6);

buf.writeUIntBE(1447656645380, 0, 6);
// &lt;Buffer 01 51 0f 0f 63 04&gt;

buf.readUIntBE(0, 6);
// 1447656645380
</code></pre>
<p>在使用Node.js编写一些底层功能时，比如一个网络通信模块、某个数据库的客户端模块，或者需要从文件中操作大量结构化数据时，以上Buffer对象提供的API都是必不可少的。</p>
<p>接下来将演示一个使用Buffer对象操作结构化数据的例子。</p>
<h2><a id="_113"></a>操作结构化数据</h2>
<p>假设有一个学生考试成绩数据库，每条记录结构如下：</p>
<table>
<thead>
<tr>
<th>学号</th>
<th>课程代码</th>
<th>分数</th>
</tr>
</thead>
<tbody>
<tr>
<td>XXXXXX</td>
<td>XXXX</td>
<td>XX</td>
</tr>
</tbody>
</table>
<p>其中学号是一个6位的数字，课程代码是一个4位数字，分数最高分为100分。</p>
<p>在使用文本来存储这些数据时，比如使用CSV格式存储可能是这样的：</p>
<pre><code>100001,1001,99
100002,1001,67
100003,1001,88
</code></pre>
<p>其中每条记录占用15字节的空间，而使用二进制存储时其结构将会是这样：</p>
<table>
<thead>
<tr>
<th>学号</th>
<th>课程代码</th>
<th>分数</th>
</tr>
</thead>
<tbody>
<tr>
<td>3字节</td>
<td>2字节</td>
<td>1字节</td>
</tr>
</tbody>
</table>
<p>每一条记录仅需要6字节的空间即可，仅仅是使用文本存储的40%！下面是用来操作这些记录的程序：</p>
<pre><code class="prettyprint javascript">// 读取一条记录
// buf    Buffer对象
// offset 本条记录在Buffer对象的开始位置
// data   {number, lesson, score}
function writeRecord (buf, offset, data) {
  buf.writeUIntBE(data.number, offset, 3);
  buf.writeUInt16BE(data.lesson, offset + 3);
  buf.writeInt8(data.score, offset + 5);
}

// 写入一条记录
// buf    Buffer对象
// offset 本条记录在Buffer对象的开始位置
function readRecord (buf, offset) {
  return {
    number: buf.readUIntBE(offset, 3),
    lesson: buf.readUInt16BE(offset + 3),
    score: buf.readInt8(offset + 5)
  };
}

// 写入记录列表
// list  记录列表，每一条包含 {number, lesson, score}
function writeList (list) {
  var buf = new Buffer(list.length * 6);
  var offset = 0;
  for (var i = 0; i &lt; list.length; i++) {
    writeRecord(buf, offset, list[i]);
    offset += 6;
  }
  return buf;
}

// 读取记录列表
// buf  Buffer对象
function readList (buf) {
  var offset = 0;
  var list = [];
  while (offset &lt; buf.length) {
    list.push(readRecord(buf, offset));
    offset += 6;
  }
  return list;
}
</code></pre>
<p>我们可以再编写一段程序来看看效果：</p>
<pre><code class="prettyprint javascript">var list = [
  {number: 100001, lesson: 1001, score: 99},
  {number: 100002, lesson: 1001, score: 88},
  {number: 100003, lesson: 1001, score: 77},
  {number: 100004, lesson: 1001, score: 66},
  {number: 100005, lesson: 1001, score: 55},
];
console.log(list);

var buf = writeList(list);
console.log(buf);
// 输出 &lt;Buffer 01 86 a1 03 e9 63 01 86 a2 03 e9 58 01 86 a3 03 e9 4d 01 86 a4 03 e9 42 01 86 a5 03 e9 37&gt;

var ret = readList(buf);
console.log(ret);
/* 输出
[ { number: 100001, lesson: 1001, score: 99 },
  { number: 100002, lesson: 1001, score: 88 },
  { number: 100003, lesson: 1001, score: 77 },
  { number: 100004, lesson: 1001, score: 66 },
  { number: 100005, lesson: 1001, score: 55 } ]
*/
</code></pre>
<h2><a id="leiproto_213"></a>lei-proto模块介绍</h2>
<p>上面的例子中，当每一条记录的结构有变化时，我们需要修改<code>readRecord()</code>和<code>writeRecord()</code>，重新计算每一个字段在Buffer中的偏移量，当记录的字段比较复杂时很容易出错。为此我编写了<code>lei-proto</code>模块，它允许你通过简单定义每条记录的结构即可生成对应的<code>readRecord()</code>和`writeRecord()函数。</p>
<p>首先执行以下命令安装此模块：</p>
<pre><code class="prettyprint bash">$ npm install lei-proto --save
</code></pre>
<p>使用<code>lei-proto</code>模块后，前文的例子可以改为这样：</p>
<pre><code class="prettyprint javascript">var parsePorto = require('lei-proto');

// 生成指定记录结构的数据编码/解码器
var record = parsePorto([
  ['number', 'uint', 3],
  ['lesson', 'uint', 2],
  ['score', 'uint', 1]
]);

function readList (buf) {
  var list = [];
  var offset = 0;
  while (offset &lt; buf.length) {
    list.push(record.decode(buf.slice(offset, offset + 6)));
    offset += 6;
  }
  return list;
}

function writeList (list) {
  return Buffer.concat(list.map(record.encodeEx));
}
</code></pre>
<p>运行与上文同样的测试程序，可看到其结果是一样的：</p>
<pre><code>&lt;Buffer 01 86 a1 03 e9 63 01 86 a2 03 e9 58 01 86 a3 03 e9 4d 01 86 a4 03 e9 42 01 86 a5 03 e9 37&gt;
[ { number: 100001, lesson: 1001, score: 99 },
  { number: 100002, lesson: 1001, score: 88 },
  { number: 100003, lesson: 1001, score: 77 },
  { number: 100004, lesson: 1001, score: 66 },
  { number: 100005, lesson: 1001, score: 55 } ]
</code></pre>
<p>关于<code>lei-proto</code>模块的详细使用方法可访问该模块的主页浏览：<a href="https://github.com/leizongmin/node-lei-proto">https://github.com/leizongmin/node-lei-proto</a></p>
<p>对此感兴趣的读者也可研究一下其实现原理。</p>
<h2><a id="_266"></a>扩展阅读</h2>
<ul>
<li><a href="http://www.infoq.com/cn/articles/nodejs-about-buffer">Buffer那些事儿</a></li>
<li><a href="https://cnodejs.org/topic/5189ff4f63e9f8a54207f60c">浅析nodejs的buffer类</a></li>
<li><a href="https://cnodejs.org/topic/4faf65852e8fb5bc65113403">小心buffer的拼接问题</a></li>
<li><a href="http://blog.fens.me/nodejs-buffer/">Node.js缓冲模块Buffer</a></li>
<li><a href="http://www.tutorialspoint.com/nodejs/nodejs_buffers.htm">Node.js - Buffers</a></li>
<li><a href="https://docs.nodejitsu.com/articles/advanced/buffers/how-to-use-buffers">How to Use Buffers in Node.js</a></li>
<li><a href="https://nodejs.org/api/buffer.html">Node.js API Documentation - Buffer</a></li>
</ul>

  </article>

  <p id="license">
  <a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/"><img alt="知识共享许可协议" style="border-width:0" src="https://i.creativecommons.org/l/by-nc/4.0/88x31.png" /></a><br />本作品由<a xmlns:cc="http://creativecommons.org/ns#" href="http://morning.work" property="cc:attributionName" rel="cc:attributionURL">老雷</a>创作，采用<a rel="license" href="http://creativecommons.org/licenses/by-nc-nd/4.0/">知识共享署名-非商业性使用-禁止演绎 4.0 国际许可协议</a>进行许可。
  </p>
</body>
</html>

<link rel="stylesheet" href="//cdn.staticfile.org/prettify/r298/prettify.min.css">
<script src="//cdn.staticfile.org/prettify/r298/prettify.min.js"></script>
<script>
prettyPrint();
</script>

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-26599868-2', 'auto');
  ga('send', 'pageview');
</script>


<!-- 多说评论框 start -->
<div class="ds-thread" data-thread-key="/2015-11/nodejs_buffer.html" data-title="Node.js的Buffer那些你可能不知道的用法 - 早起搬砖 morning.work" data-url="http://morning.work/page/2015-11/nodejs_buffer.html"></div>
<!-- 多说评论框 end -->
<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
<script type="text/javascript">
var duoshuoQuery = {
  short_name: "morningwork"
};
(function() {
  var ds = document.createElement('script');
  ds.type = 'text/javascript';
  ds.async = true;
  ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
  ds.charset = 'UTF-8';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(ds);
})();
</script>
<!-- 多说公共JS代码 end -->
<!-- 百度自动推送URL start -->
<script>
(function(){
  if (window.location.hostname === 'morning.work') {
    var bp = document.createElement('script');
    bp.src = '//push.zhanzhang.baidu.com/push.js';
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
  }
})();
</script>
<!-- 百度自动推送URL end -->

