<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<title>ES2015 &amp; babel 实战：开发NPM模块 - 早起搬砖 morning.work</title>
<style>
body {
  font-family: "Segoe UI", "Lucida Grande", Helvetica, Arial, "Microsoft YaHei", FreeSans, Arimo, "Droid Sans","wenquanyi micro hei","Hiragino Sans GB", "Hiragino Sans GB W3", Arial, sans-serif;
  width: 92%;
  max-width: 800px;
  margin: auto;
  font-weight: 400;
  color: rgba(0, 0, 0, 0.8);
  -webkit-font-smoothing: antialiased;
  word-break: break-word;
  font-size: 100%;
  line-height: 1.6;
}
#ds-thread {
  margin-top: 100px;
}
blockquote {
  font-size: 14px;
  color: rgba(0, 0, 0, 0.6);
  margin: 16px 24px;
}
code {
  padding: 0 6px;
  font-size: 0.875em;
  word-break: break-word;
  color: #c7254e;
  background-color: #f7f7f8;
  font-family: Consolas,Menlo,Monaco,"Courier New",monospace;
  font-weight: 400;
  text-rendering: optimizeSpeed;
  border-radius: 3px;
}
pre {
  line-height: 1.45;
  padding: 16px;
  background-color: #f7f7f8;
  border-radius: 3px;
}
pre code {
  padding: 0;
  color: rgba(0,0,0,.9);
}
h2 {
  border-bottom: 1px solid #CCC;
  margin-top: 32px;
}
a {
  color: #008E59;
  text-decoration: none;
}
a:hover {
  color: #B60000;
}
hr {
  border: none;
  border-bottom: 2px solid #CCC;
  margin: 20px 0 40px 0;
}
table {
  max-width: 100%;
  background-color: transparent;
  border-collapse: collapse;
  border-spacing: 0;
}
td, th {
  border: 1px solid #CCC;
  padding: 4px 16px;
}
#nav {
  border-bottom: 2px solid #eee;
  font-size: 18px;
}
#license {
  font-size: 14px;
  background-color: #f7f7f8;
  padding: 16px 6px;
}
#content {
  min-height: 200px;
}
#content img {
  display: block;
  max-width: 100%;
  margin: auto;
}
li > p {
  margin-top: 5px;
  margin-bottom: 0.4em;
}
</style>
</head>
<body>
  <nav id="nav">
    <a href="http://morning.work">早起搬砖 morning.work</a>
  </nav>

  <h1>ES2015 &amp; babel 实战：开发NPM模块</h1>
  <article id="content">
    <h2><a id="_2"></a>前言</h2>
<p>近一年来，JavaScript界关于ES6（ECMAScript 6，本文简称ES6）的讨论越来激烈，作为未来要统一全宇宙的语言（<strong>PHP是世界上最好的语言，但JavaScript终将统一全宇宙</strong>），JavaScript的运行环境众多，对ECMAScript标准的支持程度不一，所以对于ES6我一直处于观望状态。</p>
<p>前不久ES6标准正式发布，而Node.js也在最近刚刚发布了5.1.0版本，对ES6标准的支持也越来越完善，babel（一个将ES6/ES7写的代码转换为ES5代码的编译器）也发布了6.0版本，近期也涌现出了不少好文章（比如小问写的<a href="http://gank.io/post/564151c1f1df1210001c9161">「给 JavaScript 初心者的 ES2015 实战」</a>），种种迹象表明ES6真的要火了，而我也终于按耐不住了……</p>
<p>这几天正在写一个<a href="https://github.com/leizongmin/node-lei-download">方便下载文件的模块</a>（可以得到下载进度信息），正好可以使用ES6新语法特性来改写，作为我写下的第一个使用ES6语法的NPM模块。本文内容将分为以下几部分：</p>
<ul>
<li>配置babel编译环境</li>
<li>编写模块</li>
<li>单元测试</li>
<li>发布模块</li>
</ul>
<p>本文会简略介绍文中出现的ES2015新语法，具体介绍可阅读阮一峰所著的<a href="http://es6.ruanyifeng.com/">「ECMAScript 6 入门」</a>或babel官方文档中的<a href="http://babeljs.io/docs/learn-es2015/">「Learn ES2015」</a>。</p>
<p>babel官方提供了一个在线REPL，可以实时输出转换后的JavaScript代码，并且看到其运行结果，对于初学者尤其有用。访问网址http://babeljs.io/repl ，其界面如下：</p>
<p><img src="../../images/2015-11/babel_online_repl.jpg" alt="babel online repl"></p>
<p>说明：使用时勾选左边的<code>Experimental</code>可使用最新的语法特性</p>
<h2><a id="_24"></a>软件环境</h2>
<p>由于相关软件和模块正处于高速发展期，无法保证你阅读这篇文章的时候还能照着一步一步<strong>准确无误</strong>地运行下去，以下列出所用到的软件和模块的版本：</p>
<ul>
<li><strong>Node.js</strong> <code>v5.1.0</code></li>
<li><strong>npm</strong> <code>3.3.12</code></li>
<li><strong>babel</strong> <code>6.2.0 (babel-core 6.2.1)</code></li>
<li><strong>mocha</strong> <code>2.3.4</code></li>
</ul>
<h2><a id="babel_33"></a>配置babel编译环境</h2>
<h3><a id="1babel_35"></a>1、安装babel</h3>
<blockquote>
<p>Babel is a JavaScript compiler. Use next generation JavaScript, today</p>
</blockquote>
<p>目前最新版的Node.js（v5.1.0）还未完全支持ES2015的新语法特性，而且我们编写的模块可能要在Node v0.12.x或更低版本下运行，因此需要借助babel将ES2015标准的JavaScript程序转换成ES5标准的。</p>
<p>执行以下命令安装babel：</p>
<pre><code class="prettyprint bash">$ npm i -g babel-cli@6.2.0
</code></pre>
<p>由于babel依赖的模块比较多，可能会花费比较长的时间甚至安装不成功，可以尝试使用cnpmjs的NPM镜像，比如（简单在安装命令末尾添加<code>--registry=http://registry.npm.taobao.org</code>）：</p>
<pre><code class="prettyprint bash">$ npm i -g babel-cli@6.2.0 --registry=http://registry.npm.taobao.org
</code></pre>
<p>cnpmjs镜像的详细介绍可访问其官网：<a href="http://cnpmjs.org/">http://cnpmjs.org/</a></p>
<p>安装完成后，系统将获得以下两个命令：</p>
<ul>
<li><code>babel</code> 编译器</li>
<li><code>babel-node</code> 可以直接运行ES2015程序的Node命令</li>
</ul>
<p><code>babel-cli</code>的详细用法可以参考其文档：<a href="https://babeljs.io/docs/usage/cli/">https://babeljs.io/docs/usage/cli/</a></p>
<h3><a id="2_62"></a>2、初始化项目</h3>
<p>执行以下命令初始化项目（执行<code>npm init</code>时需要按提示输入相应信息，可直接按回车跳过）：</p>
<pre><code class="prettyprint bash">$ mkdir es2015_demo &amp;&amp; cd es2015_demo &amp;&amp; git init &amp;&amp; npm init
</code></pre>
<p>现在我们新建一个文件<code>test.js</code>试试是否能正常运行：</p>
<pre><code class="prettyprint javascript">function sleep(ms = 0) {
  return new Promise(function (resolve, reject) {
    setTimeout(resolve, ms);
  });
}

async function test() {
  for (let i = 0; i &lt; 10; i++) {
    await sleep(500);
    console.log(`i=${i}`);
  }
}

test().then(() =&gt; console.log('done'));
</code></pre>
<p>执行以下命令运行<code>test.js</code>：</p>
<pre><code class="prettyprint bash">$ babel-node test.js
</code></pre>
<p>在我本机的环境下显示以下错误信息：</p>
<pre><code>/usr/local/lib/node_modules/babel-cli/node_modules/babel-core/lib/transformation/file/index.js:540
      throw err;
      ^

SyntaxError: /Users/glen/work/tmp/es2015_demo/test.js: Unexpected token (7:6)
   5 | }
   6 |
&gt;  7 | async function test() {
     |       ^
   8 |   for (let i = 0; i &lt; 10; i++) {
   9 |     await sleep(500);
  10 |     console.log(`i=${i}`);

...
</code></pre>
<p>由提示信息可判断出，应该是不支持<code>async function</code>导致的，因为这是ES7标准中定义的新语法，需要配置相应的babel插件才能支持它。本文为了方面使用最新的JavaScript语法，暂时不考虑babel的编译性能，直接开启所有可能用到的插件，具体可以自行研究babel的官方文档。</p>
<p>新建文件<code>.babelrc</code>：</p>
<pre><code class="prettyprint json">{
  &quot;presets&quot;: [&quot;es2015&quot;, &quot;stage-0&quot;]
}
</code></pre>
<p><code>.babelrc</code>为babel的配置文件，保存在项目的根目录下，其中<code>presets</code>用于设置开启的语法特性集合，详细介绍可参考官方文档：<a href="https://babeljs.io/docs/usage/babelrc/">https://babeljs.io/docs/usage/babelrc/</a> 和 <a href="http://babeljs.io/docs/plugins/#presets">http://babeljs.io/docs/plugins/#presets</a></p>
<p>由于当前版本的babel没有预置<code>stage-0</code>，所以我们还需要执行以下命令安装并保存到<code>package.json</code>的<code>devDependencies</code>中：</p>
<pre><code class="prettyprint bash">$ npm i babel-preset-stage-0 --save-dev
</code></pre>
<p>现在再重新执行<code>test.js</code>，可看到控制台每隔500ms打印出一行，直到输出<code>done</code>时结束：</p>
<pre><code class="prettyprint bash">$ babel-node test.js

i=0
i=1
i=2
i=3
i=4
i=5
i=6
i=7
i=8
i=9
done
</code></pre>
<h3><a id="3_150"></a>3、编译程序</h3>
<p>在发布项目时，要求可以在不依赖babel编译器的环境下运行，因此我们需要将ES2015的程序编译成ES5的：</p>
<pre><code class="prettyprint bash">$ babel test.js --out-file test.compiled.js
</code></pre>
<p>执行上面的命令后，生成了编译后的文件<code>test.compiled.js</code>，我们尝试执行它看看：</p>
<pre><code class="prettyprint bash">$ node test.compiled.js
</code></pre>
<p>在我的系统环境下提示以下出错信息：</p>
<pre><code>/Users/glen/work/tmp/es2015_demo/test.compiled.js:4
  var ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee() {
                              ^

ReferenceError: regeneratorRuntime is not defined
    at /Users/glen/work/tmp/es2015_demo/test.compiled.js:4:31

...
</code></pre>
<p>经阅读官方文档可知，编译后的JavaScript程序有时候需要依赖一些运行时<code>polyfill</code>，通过安装<code>babel-polyfill</code>模块来获得：</p>
<pre><code class="prettyprint bash">$ npm i babel-polyfill --save
</code></pre>
<p>然后，我们需要修改编译后的文件<code>test.compiled.js</code>，在其首行加上以下代码来载入<code>babel-polyfill</code>：</p>
<pre><code class="prettyprint javascript">require('babel-polyfill');
</code></pre>
<p>再次执行<code>test.compiled.js</code>便可看到与<code>$ babel-node test.js</code>一样的结果。</p>
<p><code>polyfill</code>的详细介绍可参考官方文档：<a href="http://babeljs.io/docs/usage/polyfill/">http://babeljs.io/docs/usage/polyfill/</a></p>
<p>至此，我们已经配置了一个能使用ES2015语法的Node.js运行环境了。</p>
<h2><a id="_196"></a>编写模块</h2>
<h3><a id="1_198"></a>1、功能描述</h3>
<p>本文以<a href="https://github.com/leizongmin/node-lei-download">lei-download</a>模块为例，该模块是一个主要功能是根据一个URL来下载文件到本地，或者本地直接文件的复制，同时提供下载/复制进度信息。其使用方法如下：</p>
<pre><code class="prettyprint javascript">let download = require('lei-download');

download('http://avatars.githubusercontent.com/u/841625', 'avatar.jpg', (size, total) =&gt; {
  console.log(`已下载${size}，总共${total}`);
}, (err, filename) =&gt; {
  if (err) {
    console.error(err);
  } else {
    console.log(`已保存到${filename}`);
  }
});
</code></pre>
<p><code>download()</code>函数支持以下参数组合：</p>
<ul>
<li><code>download(source, callback);</code></li>
<li><code>download(source, progress, callback);</code></li>
<li><code>download(source, target, callback);</code></li>
<li><code>download(source, target, progress, callback);</code></li>
</ul>
<p>参数说明如下：</p>
<ul>
<li><code>source</code> 源文件，可以为本地文件或URL（<a href="http://xn--https-wm6j">http://或https</a>://开头）</li>
<li><code>target</code> 目标文件，可省略，默认生成一个在本地临时目录的随机文件名</li>
<li><code>progress</code> 下载进度，可省略</li>
<li><code>callback</code> 回调函数</li>
</ul>
<p>在编写模块时，我们首先要实现以下两个函数的功能：</p>
<ul>
<li><code>downloadFile(source, target, progress, callback)</code> 从一个URL下载文件并保存到本地</li>
<li><code>copyFile(source, target, progress, callback)</code> 复制一个本地文件</li>
</ul>
<p>然后在编写一个<code>download()</code>函数来判断<code>source</code>参数，并选择使用<code>downloadFile()</code>或者<code>copyFile()</code>来完成请求。</p>
<h3><a id="2_237"></a>2、编写程序</h3>
<p>在本项目中，所有的ES2015源程序均保存在<code>src</code>目录下，发布项目时会执行相应的命令将其编译并输出到<code>lib</code>目录，具体方法在**「发布模块」**小节中介绍。</p>
<p>实现<code>copyFile()</code>函数，新建文件<code>src/copy.js</code>：</p>
<pre><code class="prettyprint javascript">import fs from 'fs';

export default function copyFile(source, target, progress, callback) {
  fs.stat(source, (err, stats) =&gt; {
    if (err) return callback(err);

    let ss = fs.createReadStream(source);
    let ts = fs.createWriteStream(target);
    ss.on('error', callback);
    ts.on('error', callback);

    let copySize = 0;
    ss.on('data', data =&gt; {
      copySize += data.length;
      progress &amp;&amp; progress(copySize, stats.size);
    });

    ss.on('end', () =&gt; callback(null, target));

    ss.pipe(ts);
  });
}
</code></pre>
<p>说明：</p>
<ul>
<li><code>import fs from 'fs'</code>为ES2015模块系统加载模块的方式，可理解为<code>var fs = require('fs')</code>，具体在下文「模块系统」一节中介绍。</li>
<li>通过<code>fs.createReadStream(source)</code>和<code>fs.createWriteStream(target)</code>来创建读取文件流和写入文件流，并监听读取文件流的<code>data</code>事件获得当前进度信息。</li>
<li><code>export default function copyFile() {}</code>将函数<code>copyFile()</code>作为模块输出，相当于<code>module.exports = function copyFile() {}</code>，具体在下文「模块系统」一节中介绍。</li>
</ul>
<p>为了测试该代码能否正常工作，可在文件末尾增加以下测试程序（在编写单元测试时将删除）：</p>
<pre><code class="prettyprint javascript">copyFile(__filename, '/tmp/copy.js', (size, total) =&gt; {
  console.log(`进度${size}/${total}`);
}, (err, filename) =&gt; {
  if (err) {
    console.error(err);
  } else {
    console.log(`已保存到${filename}`);
  }
});
</code></pre>
<p>以上程序的作用是将当前JavaScript文件复制到<code>/tmp/copy.js</code>，使用<code>babel-node</code>执行该文件将得到以下结果：</p>
<pre><code class="prettyprint bash">$ babel-node src/copy.js

进度749/749
已保存到/tmp/copy.js
</code></pre>
<p>实现<code>downloadFile()</code>函数，新建文件<code>src/download.js</code>：</p>
<pre><code class="prettyprint javascript">import fs from 'fs';
import request from 'request';

export default function downloadFile(url, target, progress, callback) {
  let s = fs.createWriteStream(target);
  s.on('error', callback);

  let totalSize = 0;
  let downloadSize = 0;
  let req = request
    .get({
      url: url,
      encoding: null
    })
    .on('response', res =&gt; {
      if (res.statusCode !== 200) {
        return callback(new Error('status #' + res.statusCode));
      }
      totalSize = res.headers['content-length'] || null;

      res.on('data', data =&gt; {
        downloadSize += data.length;
        progress &amp;&amp; progress(downloadSize, totalSize);
      });
      res.on('end', () =&gt; callback(null, target));
    })
    .pipe(s);
}
</code></pre>
<p>说明：</p>
<ul>
<li>程序使用<code>request</code>模块来下载URL的内容，使用时执行命令<code>$ npm i request --save</code>安装该模块。</li>
<li>通过<code>request</code>模块的<code>pipe()</code>方法将收到的数据写入到<code>fs.createWriteStream(target)</code>创建的写入文件流中，<code>request</code>模块的详细使用方法可参考其文档：<a href="https://www.npmjs.com/package/request">https://www.npmjs.com/package/request</a></li>
</ul>
<p>为了测试该代码能否正常工作，可在文件末尾增加以下测试程序（在编写单元测试时将删除）：</p>
<pre><code class="prettyprint javascript">downloadFile('http://avatars.githubusercontent.com/u/841625', '/tmp/avatar.jpg', (size, total) =&gt; {
  console.log(`进度${size}/${total}`);
}, (err, filename) =&gt; {
  if (err) {
    console.error(err);
  } else {
    console.log(`已保存到${filename}`);
  }
});
</code></pre>
<p>以上程序的作用是将URL为<code>http://avatars.githubusercontent.com/u/841625</code>的文件复制到<code>/tmp/avatar.jpg</code>，使用<code>babel-node</code>执行该文件将得到以下结果：</p>
<pre><code class="prettyprint bash">$ babel-node src/download.js

进度15622/34956
进度32006/34956
进度34956/34956
已保存到/tmp/avatar.jpg
</code></pre>
<p>实现<code>download()</code>函数，新建文件<code>src/index.js</code>：</p>
<pre><code class="prettyprint javascript">import os from 'os';
import path from 'path';
import mkdirp from 'mkdirp';
import copyFile from './copy';
import downloadFile from './download';

export default function download(...args) {
  var source, target, progress, callback;
  if (args.length &lt; 2) {
    throw new TypeError('invalid argument number');
  }
  source = args[0];
  callback = args[args.length - 1];
  if (args.length === 2) {
    callback = args[1];
  } else if (args.length === 3) {
    if (typeof args[1] === 'function') {
      progress = args[1];
    } else {
      target = args[1];
    }
  } else {
    target = args[1];
    progress = args[2];
  }
  progress = progress || null;
  target = target || randomFilename(download.tmpDir);

  mkdirp(path.dirname(target), err =&gt; {
    if (err) return callback(err);

    if (isURL(source)) {
      downloadFile(source, target, progress, callback);
    } else {
      copyFile(source, target, progress, callback);
    }
  });
}

let getTmpDir = os.tmpdir || os.tmpDir;

function randomString(size = 6, chars = 'abcdefghijklmnopqrstuvwxyz0123456789') {
  let max = chars.length + 1;
  let str = '';
  while (size &gt; 0) {
    str += chars.charAt(Math.floor(Math.random() * max));
    size--;
  }
  return str;
}

function randomFilename(tmpDir = getTmpDir()) {
  return path.resolve(tmpDir, randomString(20));
}

function isURL (url) {
  if (url.substr(0, 7) === 'http://') return true;
  if (url.substr(0, 8) === 'https://') return true;
  return false;
}
</code></pre>
<p>说明：</p>
<ul>
<li><code>import copyFile from './copy'</code>用于载入模块，相当于<code>var copyFile = require('./copy')</code>。</li>
<li><code>download(...args)</code>函数中的<code>...args</code>相当于<code>var args = Array.prototype.call(arguments);</code>。</li>
<li>程序使用<code>mkdirp</code>模块来创建目标文件的上级目录，使用时执行命令<code>$ npm i mkdirp --save</code>安装该模块。</li>
<li><code>getTmpDir()</code>函数用于取得当前系统的临时目录，通过<code>os.tmpDir()</code>获得。</li>
<li><code>randomString(size)</code>函数用于生成指定长度的随机字符串。</li>
<li><code>randomFilename(tmpDir)</code>用于生成临时文件名，默认存储在系统临时目录下，可通过<code>tmpDir</code>参数指定。</li>
<li><code>isURL(url)</code>函数用于判断参数是否为一个URL。</li>
</ul>
<p>为了验证程序是否正确，我们可以将上文的<code>src/copy.js</code>和<code>src/download.js</code>中的测试程序放到<code>src/index.js</code>文件的末尾并执行（需要将旧的程序程序删除），比如：</p>
<pre><code class="prettyprint javascript">download(__filename, '/tmp/copy.js', (size, total) =&gt; {
  console.log(`进度${size}/${total}`);
}, (err, filename) =&gt; {
  if (err) {
    console.error(err);
  } else {
    console.log(`已保存到${filename}`);
  }
});
</code></pre>
<p>正常情况下，其执行结果应该跟上文中的结果是一致的。</p>
<h3><a id="3_451"></a>3、模块系统</h3>
<p>Node.js使用的是CommonJS模块系统，模块的输出我们一般通过给<code>exports</code>对象设置属性来做：</p>
<pre><code class="prettyprint javascript">// 输出变量或函数
exports.x = 123;
exports.y = function () { console.log('hello'); };
</code></pre>
<p>可以通过以下方式来操作：</p>
<pre><code class="prettyprint javascript">var mod = require('./my_module');

console.log(mod.x);
mod.y();
</code></pre>
<p>也可以通过覆盖<code>module.exports</code>来输出一个函数或者其他数据类型：</p>
<pre><code class="prettyprint javascript">module.exports = function () {
  console.log('这是一个函数');
};
</code></pre>
<p>通过以下方式来操作：</p>
<pre><code class="prettyprint javascript">var fn = require('./my_module');

fn();
</code></pre>
<p>而在ES2015中，模块通过<code>export</code>语句来输出：</p>
<pre><code class="prettyprint javascript">// 普通输出，相当于 exports.x = y;
export const a = 123;
export var b = 456;
export function c() { }
export class d { }

// 默认输出，相当于 module.exports = z;
export default function y() { }
</code></pre>
<p>通过<code>import</code>语句来引入模块，不同的引入方式其含义是不一样的，比如：</p>
<pre><code class="prettyprint javascript">// 操作 export var x = y 方式的输出
import {a, b, c, d} from './my_module';
// 通过相应的变量名称 a, b, c, d 来操作

// 或者将所有输出指向一个对象
import * as mod from './my_module';
// 通过 mod.a, mod.b, mod.c, mod.d 来操作

// 操作 export default x 方式的输出
import y from './my_module';
</code></pre>
<p>对于非ES2015程序输出的模块，<code>import * as mod</code>和<code>import mod</code>其结果是一样的，比如：</p>
<pre><code>import * as fs1 from 'fs';
import fs2 from 'fs';

// fs1.readFile() 和 fs2.readFile() 是一样的
</code></pre>
<p>为了更容易理解ES2015的模块系统原理，我们可以通过阅读编译后的JavaScript程序来了解。访问<a href="http://babeljs.io/repl/">babel的在线REPL</a>或将程序保存到本地，并执行<code>babel file.js</code>来查看编译后的程序。</p>
<p>以下ES2015代码：</p>
<pre><code class="prettyprint javascript">export const a = 123;
export var b = 456;
export function c() { }
export class d { }

export default function y() { }
</code></pre>
<p>编译后结果如下：</p>
<pre><code class="prettyprint javascript">&quot;use strict&quot;;

Object.defineProperty(exports, &quot;__esModule&quot;, {
  value: true
});
exports.c = c;
exports[&quot;default&quot;] = y;

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError(&quot;Cannot call a class as a function&quot;);
  }
}

var a = 123;
exports.a = a;
var b = 456;
exports.b = b;

function c() {}

var d = function d() {
  _classCallCheck(this, d);
};

exports.d = d;

function y() {}
</code></pre>
<p>有上面的代码可以看出，<code>export var b = 456</code>这样的输出方式，实际上相当于<code>var b = exports.b = 456</code>，即直接设置<code>exports</code>对象的属性来完成。而<code>export default y</code>则是设置<code>exports</code>对象的<code>default</code>属性。</p>
<p>另外，还设置了<code>exports.__esModule = true</code>来标记这是一个ES2015输出的模块，在通过<code>import</code>来引入模块时会判断此属性来执行相应的规则，下文将详细介绍。</p>
<p>再看看以下的ES2015代码：</p>
<pre><code class="prettyprint javascript">import {a, b, c, d} from './my_module';
import * as mod from './my_module';
import y from './my_module';

a;
mod.a;
y;
</code></pre>
<p>其编译后的JavaScript代码如下：</p>
<pre><code class="prettyprint javascript">'use strict';

function _interopRequireDefault(obj) {
  return obj &amp;&amp; obj.__esModule ? obj : {
    'default': obj
  };
}

function _interopRequireWildcard(obj) {
  if (obj &amp;&amp; obj.__esModule) {
    return obj;
  } else {
    var newObj = {};
    if (obj != null) {
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
      }
    }
    newObj['default'] = obj;
    return newObj;
  }
}

var _my_module = require('./my_module');

var mod = _interopRequireWildcard(_my_module);

var _my_module2 = _interopRequireDefault(_my_module);

_my_module.a;
mod.a;
_my_module2['default'];
</code></pre>
<p>首先，<code>a</code>是通过<code>import {a} from './my_module'</code>来引入的，编译后的代码中访问<code>a</code>使用的是<code>_my_module.a</code>，而<code>_my_module = require('./my_module')</code>，所以其对应的是<code>export var a = 123</code>这样的输出。</p>
<p><code>mod</code>是通过<code>import * as mod from './my_module'</code>来引入的，其编译后的代码为<code>_interopRequireWildcard(require('./my_module'))</code>。在<code>_interopRequireWildcard()</code>函数中，如果载入的模块是由ES2015输出的，那么不做任何处理，否则会生成一个输入模块的拷贝，并且设置其<code>default</code>属性为自身。</p>
<p><code>y</code>是通过<code>import y from './my_module'</code>来引入的，对<code>y</code>的访问被编译成了<code>_my_module2['default']</code>，所以<code>y</code>实际上是<code>export default</code>的输出。而<code>_my_module2 = _interopRequireDefault(require('./my_module'))</code>，函数<code>_interopRequireDefault()</code>对载入的非ES2015模块做了处理，会返回一个<code>default</code>属性指向该模块的新对象。</p>
<p>当然模块系统的还有更复杂的语法规则，详细说明可参考：阮一峰所著的<a href="http://es6.ruanyifeng.com/">「ECMAScript 6 入门」</a>中<a href="http://es6.ruanyifeng.com/#docs/module">Module</a>一章。</p>
<h3><a id="4_630"></a>4、封装模块</h3>
<p>上文例子中的<code>download()</code>函数所在的文件<code>src/index.js</code>中用到<code>randomFilename()</code>和<code>isURL()</code>这两个函数，为了使得代码结构更清晰，我们尝试把这些工具函数转移到<code>src/utils.js</code>中。</p>
<p>新建文件<code>src/utils.js</code>：</p>
<pre><code class="prettyprint javascript">import path from 'path';
import os from 'os';

let getTmpDir = os.tmpdir || os.tmpDir;

function randomString(size = 6, chars = 'abcdefghijklmnopqrstuvwxyz0123456789') {
  let max = chars.length + 1;
  let str = '';
  while (size &gt; 0) {
    str += chars.charAt(Math.floor(Math.random() * max));
    size--;
  }
  return str;
}

export function randomFilename(tmpDir = getTmpDir()) {
  return path.resolve(tmpDir, randomString(20));
}

export function isURL (url) {
  if (url.substr(0, 7) === 'http://') return true;
  if (url.substr(0, 8) === 'https://') return true;
  return false;
}
</code></pre>
<p>说明：<code>getTmpDir()</code>和<code>randomString()</code>仅在函数<code>randomFilename()</code>函数中用到，所以不需要使用<code>export</code>输出。</p>
<p>修改文件<code>src/index.js</code>，将相应的代码删掉，并在文件首部<code>import</code>语句后面增加以下代码：</p>
<pre><code class="prettyprint javascript">import {randomFilename, isURL} from './utils';
</code></pre>
<h2><a id="_672"></a>单元测试</h2>
<p>本文将以<code>mocha</code>测试框架为例，单元测试程序也将使用ES2015来写。</p>
<p>首先执行以下命令安装<code>mocha</code>：</p>
<pre><code class="prettyprint bash">$ npm i -g mocha
</code></pre>
<p>安装完成后可执行以下命令验证是否安装成功：</p>
<pre><code>$ mocha --version

2.3.4
</code></pre>
<p>通过阅读<code>babel</code>的官方文档（访问http://babeljs.io/docs/setup/#mocha ）可知，为了让Node.js中的<code>require()</code>函数能直接载入ES2015程序，需要依赖<code>babel-core</code>模块，执行以下命令安装：</p>
<pre><code class="prettyprint bash">$ npm i babel-core mocha --save-dev
</code></pre>
<p>运行<code>mocha</code>命令的时候，需要增加额外的参数<code>--compilers js:babel-core/register</code>让其使用<code>babel</code>来载入JavaScript程序。为了方便，我们可以修改<code>package.json</code>文件，增加以下内容：</p>
<pre><code class="prettyprint json">{
  &quot;scripts&quot;: {
    &quot;test&quot;: &quot;mocha --compilers js:babel-core/register&quot;
  }
}
</code></pre>
<p>说明：我们通过<code>npm init</code>命令生成<code>package.json</code>文件时，已经自动生成了<code>test</code>命令，其默认值为<code>echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1</code>，直接将其改为<code>mocha --compilers js:babel-core/register</code>即可。</p>
<p>以上准备工作完成后，便可以开始写单元测试程序了。新建文件<code>test/test.js</code>：</p>
<pre><code class="prettyprint javascript">import assert from 'assert';
import path from 'path';
import fs from 'fs';
import download from '../src';
import {randomFilename} from '../src/utils';

let readFile = f =&gt; fs.readFileSync(f).toString();
let getFileSize = f =&gt; fs.statSync(f).size;

describe('es2015_demo', () =&gt; {

  it('复制本地文件成功', done =&gt; {

    let source = __filename;
    let target = randomFilename();
    let onProgress = false;

    download(source, target, (size, total) =&gt; {

      onProgress = true;
      assert.equal(size, total);
      assert.equal(total, getFileSize(source));

    }, (err, filename) =&gt; {

      assert.equal(err, null);
      assert.equal(onProgress, true);
      assert.equal(target, filename);
      assert.equal(readFile(source), readFile(target));

      done();

    });
  });

});
</code></pre>
<p>说明：本文只为了演示如何配置<code>mocha</code>和编写单元测试程序，所以没有给<code>download()</code>函数编写完整的单元测试，仅编写一个测试用例作为演示。</p>
<p>好了，现在执行<code>$ npm test</code>命令看看：</p>
<pre><code class="prettyprint bash">$ npm test

&gt; es2015_demo@1.0.0 test /Users/glen/work/tmp/es2015_demo
&gt; mocha --compilers js:babel-core/register



  es2015_demo
    ✓ 复制本地文件成功


  1 passing (49ms)


</code></pre>
<p>至此，我们已经完成了使用ES2015编写模块，并使用<code>mocha</code>来进行单元测试，下文将介绍如何通过<code>babel</code>编译程序，并发布模块。</p>
<h2><a id="_773"></a>发布模块</h2>
<h3><a id="1_775"></a>1、编译</h3>
<p>上文已提到，为了让使用ES2015编写的代码能在Node.js上正常运行，需要先将其编译成ES5标准的代码，然后还需要在程序入口载入<code>babel-polyfill</code>模块。</p>
<p>我们可以修改文件<code>package.json</code>，为其增加<code>compile</code>命令：</p>
<pre><code class="prettyprint json">{
  &quot;scripts&quot;: {
    &quot;compile&quot;: &quot;babel -d lib/ src/&quot;
  }
}
</code></pre>
<p>说明：<code>$ babel -d lib/ src/</code>命令表示<code>lib</code>目录下的所有文件，并保存到<code>src</code>目录下。</p>
<p>配置完成后，可以执行<code>$ npm run compile</code>命令编译试试：</p>
<pre><code class="prettyprint bash">$ npm run compile

&gt; @isnc/es2015_demo@1.0.0 compile /Users/glen/work/tmp/es2015_demo
&gt; babel -d lib/ src/

src/copy.js -&gt; lib/copy.js
src/download.js -&gt; lib/download.js
src/index.js -&gt; lib/index.js
src/utils.js -&gt; lib/utils.js
</code></pre>
<p>此时，我们还不能直接载入<code>lib/index.js</code>文件，因为在此之前需要载入<code>babel-polyfill</code>模块。编辑文件<code>package.json</code>，设置模块入口文件：</p>
<pre><code class="prettyprint json">{
  &quot;main&quot;: &quot;index.js&quot;
}
</code></pre>
<p>说明：使用<code>$ npm init</code>生成<code>package.json</code>文件时，<code>main</code>的默认值即为<code>index.js</code>，可无需修改。</p>
<p>新建文件<code>index.js</code>：</p>
<pre><code class="prettyprint javascript">require('babel-polyfill');
module.exports = require('./lib').default;
</code></pre>
<p>说明：在<code>src/index.js</code>中<code>download()</code>函数使用的是<code>export default</code>输出，所以在Node.js中需要读取模块输出的<code>default</code>属性。</p>
<p>为了验证编译后的程序能否正常工作，可以新建文件<code>test_compiled.js</code>：</p>
<pre><code class="prettyprint javascript">var download = require('./');

download(__filename, '/tmp/copy.js', function (size, total) {
  console.log('进度%s/%s', size, total);
}, (err, filename) =&gt; {
  if (err) {
    console.error(err);
  } else {
    console.log('已保存到%s', filename);
  }
});
</code></pre>
<p>使用以下命令运行该程序是可以正常工作的：</p>
<pre><code class="prettyprint bash">$ node test_compiled.js
</code></pre>
<h3><a id="2_846"></a>2、发布</h3>
<p>我们在开发项目时，一般都会使用Git这样的源代码版本管理工具。上文例子中，<code>lib</code>目录的文件是编译生成的，可以不需要纳入到版本管理中。Node.js项目在安装模块时会将其保存到<code>node_modules</code>目录下，这些内容也是不应该纳入版本管理的。可以添加文件<code>.gitignore</code>来将其排除：</p>
<pre><code>*.log
node_modules
lib
</code></pre>
<p>如果要将模块发布到NPM上，ES2015编写的源程序也是不需要的，可以添加文件<code>.npmignore</code>来将其排除：</p>
<pre><code>src
</code></pre>
<p>在使用<code>$ npm publish</code>命令发布模块时，可以设置<code>prepublish</code>命令来让其自动执行编译。编辑文件<code>package.json</code>，增加以下内容：</p>
<pre><code class="prettyprint json">{
  &quot;scripts&quot;: {
    &quot;prepublish&quot;: &quot;npm run compile&quot;
  }
}
</code></pre>
<h3><a id="3_872"></a>3、善后</h3>
<p>上文例子中需要依赖<code>mocha</code>和<code>babel</code>两个工具，当我们开发多个项目或将其作为开源项目发布出去时，可能不同的项目所依赖<code>babel</code>的版本是不一样的，为了开发环境一致，一般我们需要在当前项目中执行其开发时所指定的<code>babel</code>版本。</p>
<p>首先执行以下命令安装<code>babel-cli</code>和<code>mocha</code>：</p>
<pre><code class="prettyprint bash">$ npm i babel-cli mocha --save-dev
</code></pre>
<p>安装完成后，对于上文中使用的<code>babel</code>和<code>mocha</code>命令，可以使用<code>./node_modules/.bin/babel</code>和<code>./node_modules/.bin/mocha</code>来执行。编辑<code>package.json</code>文件，更改<code>compile</code>和<code>test</code>命令：</p>
<pre><code class="prettyprint json">{
  &quot;scripts&quot;: {
    &quot;compile&quot;: &quot;./node_modules/.bin/babel -d lib/ src/&quot;,
    &quot;test&quot;: &quot;./node_modules/.bin/mocha --compilers js:babel-core/register&quot;
  }
}
</code></pre>
<h2><a id="_894"></a>扩展阅读</h2>
<ul>
<li><a href="http://gank.io/post/564151c1f1df1210001c9161">给 JavaScript 初心者的 ES2015 实战</a></li>
<li><a href="http://es6.ruanyifeng.com/">ECMAScript 6 入门</a></li>
<li><a href="https://blog.leancloud.cn/3910/">「大概可能也许是」目前最好的 JavaScript 异步方案 async/await</a></li>
<li><a href="http://babeljs.io/docs/learn-es2015/">Learn ES2015 - A detailed overview of ECMAScript 6 features</a></li>
<li><a href="http://mammal.io/articles/using-es6-today/">Using ES6 with npm today</a></li>
<li><a href="http://jamesknelson.com/using-es6-in-the-browser-with-babel-6-and-webpack/">Using ES6 and ES7 in the Browser, with Babel 6 and Webpack</a></li>
<li><a href="http://jamesknelson.com/writing-npm-packages-with-es6-using-the-babel-6-cli/">Writing NPM packages with ES6 using the Babel 6 CLI</a></li>
<li><a href="http://info.meteor.com/blog/set-up-sublime-text-for-meteor-es6-es2015-and-jsx-syntax-and-linting">Set up Sublime Text for Meteor ES6 (ES2015) and JSX Syntax and Linting</a></li>
<li><a href="http://exploringjs.com/es6/ch_modules.html">Exploring ES6 - Modules</a></li>
</ul>

  </article>

  <p id="license">
  <a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/"><img alt="知识共享许可协议" style="border-width:0" src="https://i.creativecommons.org/l/by-nc/4.0/88x31.png" /></a><br />本作品由<a xmlns:cc="http://creativecommons.org/ns#" href="http://morning.work" property="cc:attributionName" rel="cc:attributionURL">老雷</a>创作，采用<a rel="license" href="http://creativecommons.org/licenses/by-nc-nd/4.0/">知识共享署名-非商业性使用-禁止演绎 4.0 国际许可协议</a>进行许可。
  </p>
</body>
</html>

<link rel="stylesheet" href="//cdn.staticfile.org/prettify/r298/prettify.min.css">
<script src="//cdn.staticfile.org/prettify/r298/prettify.min.js"></script>
<script>
prettyPrint();
</script>

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-26599868-2', 'auto');
  ga('send', 'pageview');
</script>


<!-- 多说评论框 start -->
<div class="ds-thread" data-thread-key="/2015-11/es6-es7-develop-npm-module-using-babel.html" data-title="ES2015 &amp; babel 实战：开发NPM模块 - 早起搬砖 morning.work" data-url="http://morning.work/page/2015-11/es6-es7-develop-npm-module-using-babel.html"></div>
<!-- 多说评论框 end -->
<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
<script type="text/javascript">
var duoshuoQuery = {
  short_name: "morningwork"
};
(function() {
  var ds = document.createElement('script');
  ds.type = 'text/javascript';
  ds.async = true;
  ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
  ds.charset = 'UTF-8';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(ds);
})();
</script>
<!-- 多说公共JS代码 end -->
<!-- 百度自动推送URL start -->
<script>
(function(){
  if (window.location.hostname === 'morning.work') {
    var bp = document.createElement('script');
    bp.src = '//push.zhanzhang.baidu.com/push.js';
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
  }
})();
</script>
<!-- 百度自动推送URL end -->

