<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[早起搬砖 morning.work]]></title><description><![CDATA[早起搬砖 morning.work]]></description><link>http://morning.work</link><generator>RSS for Node</generator><lastBuildDate>Thu, 12 May 2016 15:57:01 GMT</lastBuildDate><atom:link href="http://morning.work/rss.xml" rel="self" type="application/rss+xml"/><language><![CDATA[zh-CN,en]]></language><ttl>60</ttl><item><title><![CDATA[Node.js 面试题： 编写一个 Redis 客户端]]></title><description><![CDATA[<blockquote>
<p>首先我要吐槽一下，<strong>招聘 Node.js 工程师真心累</strong>，虽然近两年来 Node.js 已经越来越火了，但发个招聘信息出去，投简历的也没几个。这几天好不容易连坑带拐终于勾搭上了一个，小心脏扑通扑通的久久不能平静下来，不过因为对方简历显示的主要项目经验还是前端方面的，而我们需要招的是后端，机智的我特意设计了下文这样一道面试题。</p>
<p>这样一道面试题也是临时想到的，为了确定这道题目可以在一定时间内做出来，我自己先写了一个基本可用的版本，从开始到结束约耗时两个小时（中途还去撒了两泡尿），考虑到面试者在陌生环境下可能影响正常发挥，一个下午的时间应该能应付下来。另外，我们定这样一个题目时也明确了：不要求必须完成，<strong>主要考察思路、实现逻辑、代码风格和一些可能存在的问题或错误的预判</strong>。</p>
<p>以下开始进入主题。</p>
</blockquote>
<p>前几天写了篇文章<a href="http://morning.work/page/2016-05/how-to-write-a-nodejs-api-client-package.html">《如何用 Node.js 编写一个 API 客户端》</a>（<a href="http://morning.work/page/2016-05/how-to-write-a-nodejs-api-client-package.html">http://morning.work/page/2016-05/how-to-write-a-nodejs-api-client-package.html</a> ），有人说这_不能算是一个 API 客户端，顶多是一个支持 GET / POST 操作的模块_，羞得我老脸微微一红，故作镇静地自然自语道，简单是简单点了，好歹也是个 API 客户端嘛。</p>
<p>这次要写的这个 Redis 客户端应该算是个客户端了，需要直接发起<code>TCP/IP</code>连接去跟服务器通讯，需要自己解析客户端返回的结果，还要做一些简单的容错处理，如果要做到足够健壮也不容易，不过就本文要实现一个基本可用的例子来说，还是简单了点。</p>
<p>无论是实现 REST 的 API 客户端还是这样一个 Redis 客户端，虽然具体实现的细节不同，但是，<strong>套路</strong>还是<strong>一样</strong>的。二十一世纪行走江湖最重要的是什么？套路！套路！套路！所以呢，本文还是跟之前一样的套路。</p>
<h2><a id="Redis__16"></a>Redis 协议</h2>
<p>Redis 协议的详细介绍可以参考这里：<a href="http://redis.cn/topics/protocol.html">http://redis.cn/topics/protocol.html</a></p>
<p>假如我要执行命令<code>KEYS *</code>，只要往服务器发送<code>KEYS *\r\n</code>即可，这时服务器会直接响应结果，返回的结果格式如下：</p>
<ul>
<li>用单行回复，回复的第一个字节将是<code>+</code></li>
<li>错误消息，回复的第一个字节将是<code>-</code></li>
<li>整型数字，回复的第一个字节将是<code>:</code></li>
<li>批量回复，回复的第一个字节将是<code>$</code></li>
<li>多个批量回复，回复的第一个字节将是<code>*</code></li>
</ul>
<p>每一行都使用<code>\r\n</code>来分隔。</p>
<p>为了查看具体的返回结果是怎样的，我们可以用<code>telnet</code>客户端来测试。假定本机已经运行了 Redis 服务，其监听端口为<code>6379</code>，我们可以执行以下命令连接：</p>
<pre><code class="language-bash">$ nc 127.0.0.1 6379
</code></pre>
<p>或者：</p>
<pre><code class="language-bash">$ telnet 127.0.0.1 6379
</code></pre>
<p>下面我们分别测试各个命令返回的结果（其中第一行表示客户端输入的命令，行尾的<code>↵</code>表示按回车发送，第二行开始表示服务器端返回的内容）：</p>
<p>1、返回错误</p>
<pre><code>help ↵
-ERR unknown command 'help'
</code></pre>
<p>2、操作成功</p>
<pre><code>set abc 123456 ↵
+OK
</code></pre>
<p>3、得到结果</p>
<pre><code>get abc ↵
$6
123456
</code></pre>
<p>4、得不到结果</p>
<pre><code>get aaa ↵
$-1
</code></pre>
<p>5、得到的结果是整形数字</p>
<pre><code>hlen aaa ↵
:5
</code></pre>
<p>6、多个批量回复</p>
<pre><code>keys a* ↵
*3
$3
abc
$3
aa1
$1
a
</code></pre>
<p>7、多命令执行</p>
<pre><code>multi ↵
+OK
get a ↵
+QUEUED
get b ↵
+QUEUED
get c ↵
+QUEUED
exec ↵
*3
$5
hello
$-1
$5
world
</code></pre>
<h2><a id="_114"></a>解析结果</h2>
<p>实现一个 Redis 客户端大概的原理是，客户端依次把需要执行的命令发送给服务器，而服务器会按照先后顺序把结果返回给用户。在本文我们使用 Node.js 内置的<code>net</code>模块来操作，通过<code>data</code>事件来接收结果。然而并不能一次性拿到一次请求的结果，有时可能是一个<code>data</code>事件中包含了几条命令的执行结果，也有可能当前命令的结果还没有传输完，剩下一半的结果在下一个<code>data</code>事件中。</p>
<p>为了方便调试，我们将解析结果的部分独立封装成一个函数，接口如下：</p>
<pre><code class="language-javascript"><span class="hljs-keyword">const</span> proto = <span class="hljs-keyword">new</span> RedisProto();

<span class="hljs-comment">// 接受到数据</span>
proto.push(<span class="hljs-string">'*3\r\n$3\r\nabc\r\n$3\r\naa1\r\n$1\r\na\r\n'</span>);
proto.push(<span class="hljs-string">'$6\r\n123456\r\n'</span>);
proto.push(<span class="hljs-string">'-ERR unknown command \'help\'\r\n'</span>);
proto.push(<span class="hljs-string">'+OK\r\n'</span>);
proto.push(<span class="hljs-string">':5\r\n'</span>);
proto.push(<span class="hljs-string">'*3\r\n$5\r\nhe'</span>);
proto.push(<span class="hljs-string">'llo\r\n$-'</span>);
proto.push(<span class="hljs-string">'1\r\n$5\r\nworld\r\n'</span>);

<span class="hljs-keyword">while</span> (proto.next()) {
  <span class="hljs-comment">// proto.next() 如果有解析出完整的结果则返回结果，没有则返回 false</span>
  <span class="hljs-comment">// 另外可以通过 proto.result 获得</span>
  <span class="hljs-built_in">console</span>.log(proto.result);
}
</code></pre>
<p>接下来开始编写相应的代码。</p>
<p>按照套路，我们先初始化项目：</p>
<pre><code class="language-bash">$ mkdir redis_client
$ <span class="hljs-built_in">cd</span> redis_client
$ git init
$ npm init
</code></pre>
<p>新建文件<code>proto.js</code>：</p>
<pre><code class="language-javascript"><span class="hljs-meta">'use strict'</span>;

<span class="hljs-comment">/**
 * 简单 Redis 客户端
 *
 * @author Zongmin Lei &lt;leizongmin@gmail.com&gt;
 */</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RedisProto</span> </span>{

  <span class="hljs-keyword">constructor</span>() {

    <span class="hljs-keyword">this</span>._lines = []; <span class="hljs-comment">// 已初步解析出来的行</span>
    <span class="hljs-keyword">this</span>._text = <span class="hljs-string">''</span>;  <span class="hljs-comment">// 剩余不能构成一行的文本</span>

  }

  push(text) {

    <span class="hljs-keyword">const</span> lines = (<span class="hljs-keyword">this</span>._text + text).split(<span class="hljs-string">'\r\n'</span>);
    <span class="hljs-keyword">this</span>._text = lines.pop();
    <span class="hljs-keyword">this</span>._lines = <span class="hljs-keyword">this</span>._lines.concat(lines);

  }

  next() {

    <span class="hljs-keyword">const</span> lines = <span class="hljs-keyword">this</span>._lines;
    <span class="hljs-keyword">const</span> first = lines[<span class="hljs-number">0</span>];

    <span class="hljs-keyword">const</span> popResult = (lineNumber, result) =&gt; {
      <span class="hljs-keyword">this</span>._lines = <span class="hljs-keyword">this</span>._lines.slice(lineNumber);
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.result = result;
    };

    <span class="hljs-keyword">const</span> popEmpty = () =&gt; {
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.result = <span class="hljs-literal">false</span>;
    };

    <span class="hljs-keyword">if</span> (lines.length &lt; <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> popEmpty();

    <span class="hljs-keyword">switch</span> (first[<span class="hljs-number">0</span>]) {

      <span class="hljs-keyword">case</span> <span class="hljs-string">'+'</span>:
        <span class="hljs-keyword">return</span> popResult(<span class="hljs-number">1</span>, {data: first.slice(<span class="hljs-number">1</span>)});

      <span class="hljs-keyword">case</span> <span class="hljs-string">'-'</span>:
        <span class="hljs-keyword">return</span> popResult(<span class="hljs-number">1</span>, {error: first.slice(<span class="hljs-number">1</span>)});

      <span class="hljs-keyword">case</span> <span class="hljs-string">':'</span>:
        <span class="hljs-keyword">return</span> popResult(<span class="hljs-number">1</span>, {data: <span class="hljs-built_in">Number</span>(first.slice(<span class="hljs-number">1</span>))});

      <span class="hljs-keyword">case</span> <span class="hljs-string">'$'</span>: {
        <span class="hljs-keyword">const</span> n = <span class="hljs-built_in">Number</span>(first.slice(<span class="hljs-number">1</span>));
        <span class="hljs-keyword">if</span> (n === <span class="hljs-number">-1</span>) {
          <span class="hljs-keyword">return</span> popResult(<span class="hljs-number">1</span>, {data: <span class="hljs-literal">null</span>});
        } <span class="hljs-keyword">else</span> {
          <span class="hljs-keyword">const</span> second = lines[<span class="hljs-number">1</span>];
          <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> second !== <span class="hljs-string">'undefined'</span>) {
            <span class="hljs-keyword">return</span> popResult(<span class="hljs-number">2</span>, {data: second});
          } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">return</span> popEmpty();
          }
        }
      }

      <span class="hljs-keyword">case</span> <span class="hljs-string">'*'</span>: {
        <span class="hljs-keyword">const</span> n = <span class="hljs-built_in">Number</span>(first.slice(<span class="hljs-number">1</span>));
        <span class="hljs-keyword">if</span> (n === <span class="hljs-number">0</span>) {
          <span class="hljs-keyword">return</span> popResult(<span class="hljs-number">1</span>, {data: []});
        } <span class="hljs-keyword">else</span> {
          <span class="hljs-keyword">const</span> array = [];
          <span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>;
          <span class="hljs-keyword">for</span> (; i &lt; lines.length &amp;&amp; array.length &lt; n; i++) {
            <span class="hljs-keyword">const</span> a = lines[i];
            <span class="hljs-keyword">const</span> b = lines[i + <span class="hljs-number">1</span>];
            <span class="hljs-keyword">if</span> (a.slice(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>) === <span class="hljs-string">'$-1'</span>) {
              array.push(<span class="hljs-literal">null</span>);
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (a[<span class="hljs-number">0</span>] === <span class="hljs-string">':'</span>) {
              array.push(<span class="hljs-built_in">Number</span>(a.slice(<span class="hljs-number">1</span>)));
            } <span class="hljs-keyword">else</span> {
              <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> b !== <span class="hljs-string">'undefined'</span>) {
                array.push(b);
                i++;
              } <span class="hljs-keyword">else</span> {
                <span class="hljs-keyword">return</span> popEmpty();
              }
            }
          }
          <span class="hljs-keyword">if</span> (array.length === n) {
            <span class="hljs-keyword">return</span> popResult(i, {data: array});
          } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">return</span> popEmpty();
          }
        }
      }

      <span class="hljs-keyword">default</span>:
        <span class="hljs-keyword">return</span> popEmpty();

    }

  }

}

<span class="hljs-built_in">module</span>.exports = RedisProto;
</code></pre>
<p>执行上文中的测试代码可得到如下结果：</p>
<pre><code class="language-javascript">{ data: <span class="hljs-string">'123456'</span> }
{ data: [ <span class="hljs-string">'abc'</span>, <span class="hljs-string">'aa1'</span>, <span class="hljs-string">'a'</span> ] }
{ error: <span class="hljs-string">'ERR unknown command \'help\''</span> }
{ data: <span class="hljs-string">'OK'</span> }
{ data: <span class="hljs-number">5</span> }
{ data: [ <span class="hljs-string">'hello'</span>, <span class="hljs-literal">null</span>, <span class="hljs-string">'world'</span> ] }
</code></pre>
<h2><a id="_Redis__275"></a>实现 Redis 客户端</h2>
<p>新建文件<code>index.js</code>：</p>
<pre><code class="language-javascript"><span class="hljs-meta">'use strict'</span>;

<span class="hljs-comment">/**
 * 简单 Redis 客户端
 *
 * @author Zongmin Lei &lt;leizongmin@gmail.com&gt;
 */</span>

<span class="hljs-keyword">const</span> events = <span class="hljs-built_in">require</span>(<span class="hljs-string">'events'</span>);
<span class="hljs-keyword">const</span> net = <span class="hljs-built_in">require</span>(<span class="hljs-string">'net'</span>);
<span class="hljs-keyword">const</span> RedisProto = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./proto'</span>);

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Redis</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">events</span>.<span class="hljs-title">EventEmitter</span> </span>{

  <span class="hljs-keyword">constructor</span>(options) {
    <span class="hljs-keyword">super</span>();

    options = options || {};
    options.host = options.host || <span class="hljs-string">'127.0.0.1'</span>;
    options.port = options.port || <span class="hljs-number">6379</span>;

    <span class="hljs-keyword">this</span>.options = options;

    <span class="hljs-keyword">this</span>._isClosed = <span class="hljs-literal">false</span>;
    <span class="hljs-keyword">this</span>._isConnected = <span class="hljs-literal">false</span>;
    <span class="hljs-keyword">this</span>._callbacks = [];

    <span class="hljs-keyword">this</span>._proto = <span class="hljs-keyword">new</span> RedisProto();

    <span class="hljs-keyword">this</span>.connection = net.createConnection(options.port, options.host, () =&gt; {
      <span class="hljs-keyword">this</span>._isConnected = <span class="hljs-literal">true</span>;
      <span class="hljs-keyword">this</span>.emit(<span class="hljs-string">'connect'</span>);
    });

    <span class="hljs-keyword">this</span>.connection.on(<span class="hljs-string">'error'</span>, err =&gt; {
      <span class="hljs-keyword">this</span>.emit(<span class="hljs-string">'error'</span>, err);
    });

    <span class="hljs-keyword">this</span>.connection.on(<span class="hljs-string">'close'</span>, () =&gt; {
      <span class="hljs-keyword">this</span>._isClosed = <span class="hljs-literal">true</span>;
      <span class="hljs-keyword">this</span>.emit(<span class="hljs-string">'close'</span>);
    });

    <span class="hljs-keyword">this</span>.connection.on(<span class="hljs-string">'end'</span>, () =&gt; {
      <span class="hljs-keyword">this</span>.emit(<span class="hljs-string">'end'</span>);
    });

    <span class="hljs-keyword">this</span>.connection.on(<span class="hljs-string">'data'</span>, data =&gt; {
      <span class="hljs-keyword">this</span>._pushData(data);
    });

  }

  sendCommand(cmd, callback) {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>((resolve, reject) =&gt; {

      <span class="hljs-keyword">const</span> cb = (err, ret) =&gt; {
        callback &amp;&amp; callback(err, ret);
        err ? reject(err) : resolve(ret);
      };

      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>._isClosed) {
        <span class="hljs-keyword">return</span> cb(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'connection has been closed'</span>));
      }

      <span class="hljs-keyword">this</span>._callbacks.push(cb);
      <span class="hljs-keyword">this</span>.connection.write(<span class="hljs-string">`<span class="hljs-subst">${cmd}</span>\r\n`</span>);

    });
  }

  _pushData(data) {

    <span class="hljs-keyword">this</span>._proto.push(data);

    <span class="hljs-keyword">while</span> (<span class="hljs-keyword">this</span>._proto.next()) {

      <span class="hljs-keyword">const</span> result = <span class="hljs-keyword">this</span>._proto.result;
      <span class="hljs-keyword">const</span> cb = <span class="hljs-keyword">this</span>._callbacks.shift();

      <span class="hljs-keyword">if</span> (result.error) {
        cb(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(result.error));
      } <span class="hljs-keyword">else</span> {
        cb(<span class="hljs-literal">null</span>, result.data);
      }

    }

  }

  end() {
    <span class="hljs-keyword">this</span>.connection.destroy();
  }

}

<span class="hljs-built_in">module</span>.exports = Redis;
</code></pre>
<p>说明：</p>
<ul>
<li>每次<code>data</code>事件接收到结果时，直接将其<code>push()</code>到<code>RedisProto</code>中，并尝试执行<code>next()</code>获得结果</li>
<li>因为命令的执行结果都是按照顺序返回的，所以我们只需要按顺序从<code>this._callbacks</code>中取出最前面的元素，直接执行回调</li>
<li>如果连接已经端口，则不允许再执行命令，直接返回<code>connection has been closed</code>错误</li>
<li><code>sendCommand()</code>同时支持<code>callback</code>和<code>promise</code>方式的回调，但是套路跟上一篇文章《如何用 Node.js 编写一个 API 客户端》稍有不同</li>
</ul>
<p>新建测试文件<code>test.js</code>：</p>
<pre><code class="language-javascript"><span class="hljs-meta">'use strict'</span>;

<span class="hljs-keyword">const</span> Redis = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./simple'</span>);
<span class="hljs-keyword">const</span> client = <span class="hljs-keyword">new</span> Redis();

client.sendCommand(<span class="hljs-string">'GET a'</span>, (err, ret) =&gt; {
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'a=%s, err=%s'</span>, ret, err);
});

client.sendCommand(<span class="hljs-string">'GET b'</span>, (err, ret) =&gt; {
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'b=%s, err=%s'</span>, ret, err);
});

client.sendCommand(<span class="hljs-string">'KEYS *IO*'</span>, (err, ret) =&gt; {
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'KEYS *IO*=%s, err=%s'</span>, ret, err);
});

client.sendCommand(<span class="hljs-string">'OOXX'</span>, (err, ret) =&gt; {
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'OOXX=%s, err=%s'</span>, ret, err);
});

client.sendCommand(<span class="hljs-string">'SET a '</span> + <span class="hljs-built_in">Date</span>.now())
  .then(ret =&gt; <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'success'</span>, ret))
  .catch(err =&gt; <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'error'</span>, err))
  .then(() =&gt; client.end());
</code></pre>
<p>执行测试文件<code>node test.js</code>可看到类似如下的结果：</p>
<pre><code>a=1463041835231, err=null
b=null, err=null
KEYS *IO*=sess:cz5F-npwOnw0FmesT6JjqJPL13IO8AzV,sess:NS90IkF6uZNAm-FPEAWXHuh3JrIW1-IO, err=null
OOXX=undefined, err=Error: ERR unknown command 'OOXX'
success OK
</code></pre>
<p>从结果中可以看出我们这个 Redis 客户端已经基本能用了。</p>
<h2><a id="_429"></a>更友好的接口</h2>
<p>上文我们实现了一个<code>sendCommand()</code>方法，理论上可以通过该方法执行任意的 Redis 命令，但是我们可能更希望每条命令有一个对应的方法，比如<code>sendCommand('GET a')</code>我们可以写成<code>get('a')</code>，这样看起来会更直观。</p>
<p>首先在<code>index.js</code>文件头部载入<code>fs</code>和<code>path</code>模块：</p>
<pre><code class="language-javascript"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>);
<span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">'path'</span>);
</code></pre>
<p>然后给<code>Redis</code>类增加<code>_bindCommands()</code>方法：</p>
<pre><code class="language-javascript">_bindCommands() {

  <span class="hljs-keyword">const</span> self = <span class="hljs-keyword">this</span>;
  <span class="hljs-keyword">const</span> bind = (cmd) =&gt; {
    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{

      <span class="hljs-keyword">let</span> args = <span class="hljs-built_in">Array</span>.prototype.slice.call(<span class="hljs-built_in">arguments</span>);
      <span class="hljs-keyword">let</span> callback;
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> args[args.length - <span class="hljs-number">1</span>] === <span class="hljs-string">'function'</span>) {
        callback = args.pop();
      }

      args = args.map(item =&gt; <span class="hljs-built_in">Array</span>.isArray(item) ? item.join(<span class="hljs-string">' '</span>) : item).join(<span class="hljs-string">' '</span>);

      <span class="hljs-keyword">return</span> self.sendCommand(<span class="hljs-string">`<span class="hljs-subst">${cmd}</span> <span class="hljs-subst">${args}</span>`</span>, callback);

    };
  };

  <span class="hljs-keyword">const</span> cmdList = fs.readFileSync(path.resolve(__dirname, <span class="hljs-string">'cmd.txt'</span>)).toString().split(<span class="hljs-string">'\n'</span>);
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> cmd <span class="hljs-keyword">of</span> cmdList) {

    <span class="hljs-keyword">this</span>[cmd.toLowerCase()] = bind(cmd);
    <span class="hljs-keyword">this</span>[cmd.toUpperCase()] = bind(cmd);

  }

}
</code></pre>
<p>然后在<code>Redis</code>类的<code>constructor()</code>方法尾部增加以下代码：</p>
<pre><code class="language-javascript"><span class="hljs-keyword">this</span>._bindCommands();
</code></pre>
<p>由于在<code>_bindCommands()</code>中通过读取<code>cmd.txt</code>文件来读取 Redis 的命令列表，所以还需要新建文件<code>cmd.txt</code>，内容格式为每条命令一行（由于篇幅限制，本文只列出需要用到的几条命令）：</p>
<pre><code>GET
SET
AUTH
MULTI
EXEC
KEYS
</code></pre>
<p>把测试文件<code>test.js</code>改为以下代码：</p>
<pre><code class="language-javascript"><span class="hljs-meta">'use strict'</span>;

<span class="hljs-keyword">const</span> Redis = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./simple'</span>);
<span class="hljs-keyword">const</span> client = <span class="hljs-keyword">new</span> Redis();

client.get(<span class="hljs-string">'a'</span>, (err, ret) =&gt; {
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'a=%s, err=%s'</span>, ret, err);
});

client.get(<span class="hljs-string">'b'</span>, (err, ret) =&gt; {
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'b=%s, err=%s'</span>, ret, err);
});

client.keys(<span class="hljs-string">'*IO*'</span>, (err, ret) =&gt; {
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'KEYS *IO*=%s, err=%s'</span>, ret, err);
});

client.set(<span class="hljs-string">'a'</span>, <span class="hljs-built_in">Date</span>.now())
  .then(ret =&gt; <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'success'</span>, ret))
  .catch(err =&gt; <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'error'</span>, err))
  .then(() =&gt; client.end())
</code></pre>
<p>重新执行<code>node test.js</code>可看到结果跟上文还是一致的。</p>
<h2><a id="_519"></a>简单容错处理</h2>
<p>假如将测试文件<code>test.js</code>改为这样：</p>
<pre><code class="language-javascript"><span class="hljs-meta">'use strict'</span>;

<span class="hljs-keyword">const</span> Redis = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./simple'</span>);
<span class="hljs-keyword">const</span> client = <span class="hljs-keyword">new</span> Redis();

client.get(<span class="hljs-string">'a'</span>, (err, ret) =&gt; {
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'a=%s, err=%s'</span>, ret, err);

  client.end();

  client.get(<span class="hljs-string">'b'</span>, (err, ret) =&gt; {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'b=%s, err=%s'</span>, ret, err);
  });
});
</code></pre>
<p>在完成<code>get('a')</code>的时候，我们执行<code>client.end()</code>关闭了连接，然后再执行<code>get('b')</code>，大多数情况下将会得到如下的结果：</p>
<pre><code>a=1463042964235, err=null
</code></pre>
<p>而<code>get('b')</code>的回调函数并没有被执行，因为我们在关闭连接后，再也没有收到服务端返回的结果。另外也有可能是因为其他原因，客户端与服务端的连接断开了，此时我们应该能执行回调并返回一个错误。</p>
<p>在文件<code>index.js</code>中给<code>Redis</code>类增加一个方法<code>_callbackAll()</code>：</p>
<pre><code class="language-javascript">_callbackAll() {

  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> cb <span class="hljs-keyword">of</span> <span class="hljs-keyword">this</span>._callbacks) {
    cb(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'connection has been closed'</span>));
  }
  <span class="hljs-keyword">this</span>._callbacks = [];

}
</code></pre>
<p>另外，在<code>constructor()</code>方法内，将监听连接的<code>close</code>事件部分代码改成这样：</p>
<pre><code class="language-javascript"><span class="hljs-keyword">this</span>.connection.on(<span class="hljs-string">'close'</span>, () =&gt; {
  <span class="hljs-keyword">this</span>._isClosed = <span class="hljs-literal">true</span>;
  <span class="hljs-keyword">this</span>.emit(<span class="hljs-string">'close'</span>);
  <span class="hljs-keyword">this</span>._callbackAll();
});
</code></pre>
<p>重新执行<code>node test.js</code>，从执行结果可看出所有回调函数均已被执行：</p>
<pre><code>a=1463042964235, err=null
b=undefined, err=Error: connection has been closed
</code></pre>
<h2><a id="_579"></a>还存在的问题</h2>
<p>看起来这个模块已经能正常使用了，但是其实并不完善。跟 NPM 上的<code>ioredis</code>模块起来还存在以下问题：</p>
<ul>
<li>不支持<code>multi()</code>命令</li>
<li>不支持<code>publish</code>和<code>subscribe</code>命令</li>
<li>不能解析更复杂的返回结果，比如<code>command</code>命令的返回结果</li>
<li>没有严格的测试，假如服务端返回了一个非预期的格式，我也不知道程序会咋样</li>
<li><code>RedisProto</code>解析结果的算法还是可以优化的，目前这个只能算是大概能用</li>
</ul>
<p>好了，我只是出个题目面面试，又不是要撸一个轮子出来，剩下的就交给你啦。</p>
<h2><a id="_592"></a>参考链接</h2>
<ul>
<li><a href="http://redis.cn/topics/protocol.html">Redis 协议</a>（<a href="http://redis.cn/topics/protocol.html%EF%BC%89">http://redis.cn/topics/protocol.html）</a></li>
</ul>
]]></description><link>http://morning.work/page/2016-05/how-to-write-a-nodejs-redis-client.html</link><guid isPermaLink="true">http://morning.work/page/2016-05/how-to-write-a-nodejs-redis-client.html</guid><dc:creator><![CDATA[老雷]]></dc:creator><pubDate>Thu, 12 May 2016 00:00:00 GMT</pubDate></item><item><title><![CDATA[如何用 Node.js 编写一个 API 客户端]]></title><description><![CDATA[<h2><a id="_2"></a>说几句无关主题的话</h2>
<p>尽管这几年来 Node.js 已经得到越来越多的关注，连市场卖菜的老太婆都能分别得出哪个是写 Node.js 的，哪个是写 PHP 的。然而，终究是不能跟老大哥 Java 比的。我们在使用一些第三方服务时常常会碰到一时半会还没有官方的 Node.js SDK 的问题，所以能自己随手撸一个刚好够用的 API 客户端来应急成了必备技能。</p>
<p>说到这里，我忍不住要先吐槽一下：</p>
<blockquote>
<p>前几天在 CNodeJS 上看到一个帖子，<a href="https://cnodejs.org/topic/56ab1c0526d02fc6626bb383">拥抱 ES6——阿里云 OSS 推出 JavaScript SDK</a>，对其中的滥用<code>generator</code>还<strong>洋洋自得</strong>的行为有点不满，之前也遇到过该厂的 SDK 强行返回<code>generator</code>而放弃使用，我想说我<strong>已经忍了很久</strong>了。</p>
<p><strong>「我自己写得爽，也希望把这种“爽”带给用户」</strong>-- <em>该 SDK 的维护者如是说</em></p>
<p><strong>作为一个 SDK（尤其是官方出品的），应该使用最 common 的技术或规范来实现</strong>。比如在 Node.js 中的异步问题，应该使用传统的<code>callback</code>或者 ES6 里面的<code>promise</code>，而不是使用比较奇葩的<code>generator</code>来做。<code>generator</code>来做不妥的地方是：</p>
<ul>
<li><code>generator</code>的出现不是为了解决异步问题</li>
<li>使用<code>generator</code>是会传染的，当你尝试<code>yield</code>一下的时候，它要求你也必须在一个<code>generator function</code>内</li>
</ul>
<p>当然，如果这是一个内部项目，使用各种花式姿势都是没问题的，只要定好规范就行。而如果这是要给别人使用的东西，应该照顾其他人的感受。</p>
<p>所以我们要自己动手写一个 SDK 还有另外一种情况就是<strong>对官方的 SDK 并不满意</strong>。</p>
<p>好了，我吐槽完了。</p>
</blockquote>
<h2><a id="_24"></a>运行环境</h2>
<p>最近一年来，Node.js 相继发布了 4.0、5.0、6.0（前几天），7.0 也已经蓄势待发，但目前来看<strong>主流还是 4.x 版本</strong>。Node.js 4.x 支持一部分的 ES6 语法，比如箭头函数、<code>let</code>和<code>const</code>等，解决异步问题也可以直接使用 ES6 的<code>promise</code>。</p>
<p>如果没有特殊情况，新写的程序可以不用考虑在 0.12 或者更早的 0.10 上运行，如果以后确实需要在些版本上执行，可以借用 Babel 来编译成 ES5 语法的程序。</p>
<p>API 接口将同时支持<code>callback</code>和<code>promise</code>两种回调方式。<code>promise</code>直接使用 ES6 原生的<code>Promise</code>对象而不是使用<code>bluebird</code>模块。尽管使用<code>bluebird</code>会有更多的功能和更好的性能，但在这样一个需要网络 IO 的场景下，那么一点性能差别基本可以忽略不计，而作为一个极简主义者，觉得没太大必要引入这么一个依赖库。</p>
<h2><a id="_33"></a>功能设计</h2>
<p>本文将以 <a href="https://cnodejs.org/api">CNodeJS 提供的 API</a> 为例。CNodeJS 的 API 分两种：</p>
<ul>
<li>公共接口，比如获取主题列表和详情等</li>
<li>用户接口，需要提供<code>accesstoken</code>参数来验证用户权限（<code>accessToken</code>可以在个人设置界面中得到）</li>
</ul>
<p>程序的使用方法如下：</p>
<pre><code class="language-javascript"><span class="hljs-meta">'use strict'</span>;

<span class="hljs-keyword">const</span> client = <span class="hljs-keyword">new</span> CNodeJS({
  token: <span class="hljs-string">'xxxxxxx'</span>, <span class="hljs-comment">// accessToken，可为空</span>
});

<span class="hljs-comment">// promise 方式调用</span>
client.getTopics({page: <span class="hljs-number">1</span>})
  .then(list =&gt; <span class="hljs-built_in">console</span>.log(list))
  .catch(err =&gt; <span class="hljs-built_in">console</span>.error(err));

<span class="hljs-comment">// callback 方式调用</span>
client.getTopics({page: <span class="hljs-number">1</span>}, (err, list) =&gt; {
  <span class="hljs-keyword">if</span> (err) {
    <span class="hljs-built_in">console</span>.error(err);
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-built_in">console</span>.log(list);
  }
});
</code></pre>
<h2><a id="_65"></a>初始化项目</h2>
<p>1、首先新建项目目录：</p>
<pre><code class="language-bash">$ mkdir cnodejs_api_client
$ <span class="hljs-built_in">cd</span> cnodejs_api_client
$ git init
</code></pre>
<p>2、初始化<code>package.json</code>：</p>
<pre><code class="language-bash">$ npm init
</code></pre>
<p>3、新建文件<code>index.js</code>：</p>
<pre><code class="language-javascript"><span class="hljs-meta">'use strict'</span>;

<span class="hljs-keyword">const</span> rawRequest = <span class="hljs-built_in">require</span>(<span class="hljs-string">'request'</span>);

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CNodeJS</span> </span>{

  <span class="hljs-keyword">constructor</span>(options) {

    <span class="hljs-keyword">this</span>.options = options = options || {};
    options.token = options.token || <span class="hljs-literal">null</span>;
    options.url = options.url || <span class="hljs-string">'https://cnodejs.org/api/v1/'</span>;

  }

  baseParams(params) {

    params = <span class="hljs-built_in">Object</span>.assign({}, params || {});
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.options.token) {
      params.accesstoken = <span class="hljs-keyword">this</span>.options.token;
    }

    <span class="hljs-keyword">return</span> params;

  }

  request(method, path, params, callback) {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>((resolve, reject) =&gt; {

      <span class="hljs-keyword">const</span> opts = {
        method: method.toUpperCase(),
        url: <span class="hljs-keyword">this</span>.options.url + path,
        json: <span class="hljs-literal">true</span>,
      };

      <span class="hljs-keyword">if</span> (opts.method === <span class="hljs-string">'GET'</span> || opts.method === <span class="hljs-string">'HEAD'</span>) {
        opts.qs = <span class="hljs-keyword">this</span>.baseParams(params);
      } <span class="hljs-keyword">else</span> {
        opts.body = <span class="hljs-keyword">this</span>.baseParams(params);
      }

      rawRequest(opts, (err, res, body) =&gt; {

        <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">return</span> reject(err);

        <span class="hljs-keyword">if</span> (body.success) {
          resolve(body);
        } <span class="hljs-keyword">else</span> {
          reject(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(body.error_msg));
        }

      });

    });
  }

}

<span class="hljs-built_in">module</span>.exports = CNodeJS;
</code></pre>
<p>说明：</p>
<ul>
<li>使用<code>request</code>模块来发送 HTTP 请求，需要执行命令来安装该模块：<code>npm install request --save</code></li>
<li>我们实现了一个带有<code>request</code>方法的<code>CNodeJS</code>类，可以通过该方法来发送任意 API 请求，比如请求主题首页是<code>request('GET', 'topics', {page: 1})</code></li>
<li>如果初始化<code>CNodeJS</code>实例时传入了<code>token</code>，则每次请求都会自动带上<code>accesstoken</code>参数</li>
<li>返回的结果<code>success=true</code>表示 API 请求成功，则直接回调该结果；如果失败则<code>error_msg</code>表示出错信息</li>
</ul>
<p>4、新建测试文件<code>test.js</code>：</p>
<pre><code class="language-javascript"><span class="hljs-meta">'use strict'</span>;

<span class="hljs-keyword">const</span> CNodeJS = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./'</span>);
<span class="hljs-keyword">const</span> client = <span class="hljs-keyword">new</span> CNodeJS();

client.request(<span class="hljs-string">'GET'</span>, <span class="hljs-string">'topics'</span>, {page: <span class="hljs-number">1</span>})
  .then(ret =&gt; <span class="hljs-built_in">console</span>.log(ret))
  .catch(err =&gt; <span class="hljs-built_in">console</span>.error(err));
</code></pre>
<p>5、执行命令<code>node test.js</code>即可看到类似以下的结果：</p>
<pre><code class="language-javascript">{ success: <span class="hljs-literal">true</span>,
  data:
   [ { id: <span class="hljs-string">'572afb6b15c24e592c16e1e6'</span>,
       author_id: <span class="hljs-string">'504c28a2e2b845157708cb61'</span>,
       tab: <span class="hljs-string">'share'</span>,
       content: <span class="hljs-string">'.......'</span>
...
</code></pre>
<p>至此我们已经完成了一个 API 客户端最基本的功能，接下来根据不同的 API 封装一下<code>request</code>方法即可。</p>
<h2><a id="_callback_178"></a>支持 callback</h2>
<p>前文已经提到，<strong>「作为一个 SDK，应该使用最 common 的技术或规范来实现」</strong>，所以除了<code>promise</code>之外还需要提供<code>callback</code>的支持。</p>
<p>1、修改文件<code>index.js</code>中<code>request(method, path, params) { }</code>定义部分：</p>
<pre><code class="language-javascript">request(method, path, params, callback) {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>((_resolve, _reject) =&gt; {

    <span class="hljs-keyword">const</span> resolve = ret =&gt; {
      _resolve(ret);
      callback &amp;&amp; callback(<span class="hljs-literal">null</span>, ret);
    };

    <span class="hljs-keyword">const</span> reject = err =&gt; {
      _reject(err);
      callback &amp;&amp; callback(err);
    };

    <span class="hljs-comment">// 以下部分不变</span>
    <span class="hljs-comment">// ...</span>
  });
}
</code></pre>
<p>说明：</p>
<ul>
<li>将<code>new Promise()</code>中的<code>resolve</code>和<code>reject</code>分别改名为<code>_resolve</code>和<code>_reject</code></li>
<li>在函数开头新建<code>resolve</code>和<code>reject</code>，其作用是调用原来的<code>_resolve</code>和<code>_reject</code>，同时判断如果有<code>callback</code>参数，则也调用该函数</li>
</ul>
<p>2、将文件<code>test.js</code>中<code>client.request()</code>部分改为 callback 方式调用：</p>
<pre><code class="language-javascript">client.request(<span class="hljs-string">'GET'</span>, <span class="hljs-string">'topics'</span>, {page: <span class="hljs-number">1</span>}, (err, ret) =&gt; {
  <span class="hljs-keyword">if</span> (err) {
    <span class="hljs-built_in">console</span>.error(err);
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-built_in">console</span>.log(ret);
  }
});
</code></pre>
<p>3、重新执行<code>node test.js</code>可以看到结果跟之前是一样的。</p>
<p>通过简单的修改我们就已经实现了同时支持<code>promise</code>和<code>callback</code>两种异步回调方式。</p>
<h2><a id="_API_226"></a>封装 API</h2>
<p>前文我们实现的<code>request()</code>方法已经可以调用任意的 API 了，但是为了是方便，一般需要为每个 API 单独封装一个方法，比如：</p>
<ul>
<li><code>getTopics()</code>- 获取主题首页</li>
<li><code>getTopicDetail()</code>- 获取主题详情</li>
<li><code>testToken()</code>- 测试<code>token</code>是否正确</li>
</ul>
<p>对于<code>getTopics()</code>可以这样简单地实现：</p>
<pre><code class="language-javascript">getTopics(params, callback) {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.request(<span class="hljs-string">'GET'</span>, <span class="hljs-string">'topics'</span>, params, callback);
}
</code></pre>
<p>但其返回的结果是这样结构的：</p>
<pre><code class="language-javascript">{ success: <span class="hljs-literal">true</span>,
  data: []
}
</code></pre>
<p>要取得结果还要读取里面的<code>data</code>，针对这种情况我们可以改成这样：</p>
<pre><code class="language-javascript">getTopics(params, callback) {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.request(<span class="hljs-string">'GET'</span>, <span class="hljs-string">'topics'</span>, params, callback)
             .then(ret =&gt; <span class="hljs-built_in">Promise</span>.resolve(ret.data));
}
</code></pre>
<p><code>getTopicDetail()</code>和<code>testToken()</code>可以这样实现：</p>
<pre><code class="language-javascript">getTopicDetail(params, callback) {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.request(<span class="hljs-string">'GET'</span>,<span class="hljs-string">`topic/<span class="hljs-subst">${params.id}</span>`</span>, params, callback)
             .then(ret =&gt; <span class="hljs-built_in">Promise</span>.resolve(ret.data));
}

testToken(callback) {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.request(<span class="hljs-string">'POST'</span>,<span class="hljs-string">`accesstoken`</span>, {}, callback);
}
</code></pre>
<p>对于其他的 API 也可以采用类似的方法一一实现。</p>
<h2><a id="_275"></a>结尾</h2>
<p>由此看来编写一个简单的 API 客户端也不是一件很难的事情，本文介绍的方法已经能适用大多数的情况了。当然还有些问题是没提到的，比如阿里云 OSS 这种 SDK 还要考虑 stream 上传问题，还有断点续传。对于安全性要求较高的 SDK 可能还需要做数据签名等等。</p>
<p>在编写本文的时候，通过阅读<code>request</code>的 API 文档我才发现原来可以通过<code>json=true</code>选项来让它自动解析返回的结果，这样确实能少写好几行代码了。</p>
<p>另外我还是忍不住再吐槽一下，CNodeJS 的 API 接口设计得并不一致，响应成功时并不是所有数据都放在<code>data</code>里面（比如<code>testToken()</code>）。</p>
<p>发觉最近有点上火了 ^_^</p>
]]></description><link>http://morning.work/page/2016-05/how-to-write-a-nodejs-api-client-package.html</link><guid isPermaLink="true">http://morning.work/page/2016-05/how-to-write-a-nodejs-api-client-package.html</guid><dc:creator><![CDATA[老雷]]></dc:creator><pubDate>Sat, 07 May 2016 00:00:00 GMT</pubDate></item><item><title><![CDATA[在 Sublime Text 上配置 ES2015 开发环境]]></title><description><![CDATA[<h2><a id="_2"></a>安装</h2>
<p>首先访问 Sublime Text 的官网 <a href="https://www.sublimetext.com/3">https://www.sublimetext.com/3</a> 下载对应系统版本的安装包：</p>
<p><img src="../../images/2016-03/1-1.png" alt="图 1-1"></p>
<p>安装提示安装完毕之后，启动 Sublime Text ，其界面如下：</p>
<p><img src="../../images/2016-03/1-2.png" alt="图 1-2"></p>
<p>其中右下角的 <strong>「Tab Size: 4」</strong> 表示当前缩进的长度，默认为 4 个空格。大多数的 JavaScript 编程风格都是使用 2 个空格长度的，点击该处可以在弹出的菜单中选择长度，并勾选 <strong>「Indent Using Spaces」</strong> 来使用空格代替 Tab 缩进，这样就能保证在不同平台下显示一致。</p>
<h2><a id="_14"></a>配置</h2>
<p>Sublime Text 的配置通过改配置文件来完成，选择菜单 <strong>Preferences &gt; Settings - User</strong>（OSX 系统下是 <strong>Sublime Text &gt; Preferences &gt; Settings - User</strong>） 即可打开配置文件，然后在打开默认的配置文件 <strong>Preferences &gt; Settings - Default</strong> 作为对照，把需要更改的项目复制到「User」配置文件并修改其值。</p>
<p>比如以下配置用来修改缩进长度和方式：</p>
<pre><code class="language-javascript">{

  <span class="hljs-comment">// The number of spaces a tab is considered equal to</span>
  <span class="hljs-string">"tab_size"</span>: <span class="hljs-number">2</span>,

  <span class="hljs-comment">// Set to true to insert spaces when tab is pressed</span>
  <span class="hljs-string">"translate_tabs_to_spaces"</span>: <span class="hljs-literal">true</span>,

}
</code></pre>
<p>详细使用方法可参考本章末尾的「相关链接」。</p>
<h2><a id="_Package_Control_34"></a>安装 Package Control</h2>
<p>使用 Sublime Text 的一大乐趣就是可以为其安装各种各样的插件，但是 Sublime Text 并没有内置插件管理器，我们需要自己去安装。</p>
<p>首先打开 Sublime Text 的包管理器安装页面 <a href="https://packagecontrol.io/installation">https://packagecontrol.io/installation</a></p>
<p><img src="../../images/2016-03/1-3.png" alt="图 1-3"></p>
<p>由于上文中我们安装的是 Sublime Text 3，所以先复制页面中 <strong>SUBLIME TEXT 3</strong> 下面对应的代码，然后转到 Sublime Text 窗口，选择菜单 <strong>View &gt; Show Console</strong>，这时编辑器窗口下面会显示一个新的窗口，在输入栏中粘贴刚才复制的代码，并按回车执行，稍等片刻即可安装完成（主要取决于当前网络环境）。</p>
<p>安装完 Package Control 之后，我们就可以随心所欲地安装需要的插件了。下面我们来介绍 Package Control 的一些基本命令：</p>
<ul>
<li><strong>Install Package</strong> - 安装插件</li>
<li><strong>Remove Package</strong> - 删除插件</li>
<li><strong>Enable Package</strong> - 启用插件</li>
<li><strong>Disable Package</strong> - 禁用插件</li>
</ul>
<p>一般常用的就是 <strong>Install Package</strong> 和 <strong>Remove Package</strong>，要执行以上命令可以在 Sublime Text 界面下按 <strong>Ctrl + Shift + P</strong> 键（在 OSX 系统下是 <strong>Command + Shift + P</strong>），这时会弹出一个下面这样的窗口：</p>
<p><img src="../../images/2016-03/1-4.png" alt="图 1-4"></p>
<p>在窗口中输入命令 <strong>Install Package</strong> 并按回车，稍等几秒，便会弹出以下窗口：</p>
<p><img src="../../images/2016-03/1-5.png" alt="图 1-5"></p>
<p>可以直接在输入框中输入插件名称来搜索插件，并通过方向键来选择要安装的插件，按回车即可安装。</p>
<h2><a id="_Sublime_Text__62"></a>常用的 Sublime Text 插件</h2>
<h3><a id="JavaScriptNext__ES6_Syntax_64"></a>JavaScriptNext - ES6 Syntax</h3>
<p>默认情况下 Sublime Text 并不支持高亮显示 ES6 语法，由于本书的示例代码主要使用 ES6 来编写，因此需要先安装此插件。</p>
<p>安装完此插件之后，需要执行以下操作将其设置为 <code>*.js</code> 文件默认的样式：</p>
<ul>
<li>打开一个 <code>.js</code> 后缀的 JavaScript 文件</li>
<li>选择菜单 <strong>View &gt; Syntax &gt; Open all with current extension as... &gt; JavascriptNext - ES6 Syntax &gt; JavascriptNext</strong>。具体使用方法可访问插件的主页查看。</li>
</ul>
<p>项目主页：<a href="https://github.com/Benvie/JavaScriptNext.tmLanguage">https://github.com/Benvie/JavaScriptNext.tmLanguage</a></p>
<h3><a id="GitGutter_75"></a>Git​Gutter</h3>
<p>如果当前编辑的文件是在一个 Git 项目下面的，安装了 GitGutter 之后可以直接在编辑器中查看到当前文件的改动情况，比如：</p>
<p><img src="../../images/2016-03/1-6.png" alt="图 1-6"></p>
<p>项目主页：<a href="https://github.com/jisaacks/GitGutter">https://github.com/jisaacks/GitGutter</a></p>
<h3><a id="SublimeLinter_83"></a>SublimeLinter</h3>
<p>SublimeLinter 主要用于在 Sublime Text 下对代码进行语法检查，这个插件安装配置会稍微复杂一些。</p>
<p>首先执行以下命令安装用于 JavaScript 语法检查的 eslint 和 babel-eslint ：</p>
<pre><code class="language-bash">$ npm install -g eslint babel-eslint
</code></pre>
<p>由于 babel-eslint 依赖的模块比较多，在国内的网络环境下可能会安装失败，可以在安装时指定使用淘宝的 NPM 镜像：</p>
<pre><code class="language-bash">$ npm install -g eslint babel-eslint --registry=http://registry.npm.taobao.org
</code></pre>
<p>安装完成后，我们再通过 Package Control 来安装 SublimeLinter 和 SublimeLinter-contrib-eslint 这两个插件。</p>
<p>现在我们来打开一个 JavaScript 文件：</p>
<p><img src="../../images/2016-03/1-7.png" alt="图 1-7"></p>
<p>如上图所示，由于 <code>hello world</code> 这一行有语法错误，该行前面会有一个红色的圆圈，并且编辑器底部会显示具体的出错信息**「Error: Parsing error: Unexpeced token, line 5, Column 9」**</p>
<p>要让 SublimeLinter 支持其他编程语言，可以搜索 <code>SublimeLinter-</code> 开头的插件并安装。</p>
<p>项目主页：<a href="http://www.sublimelinter.com/">http://www.sublimelinter.com/</a></p>
<h2><a id="_111"></a>相关链接</h2>
<ul>
<li><a href="http://blog.jobbole.com/79326/">推荐！Sublime Text 最佳插件列表</a></li>
<li><a href="http://dengo.org/archives/923">Sublime Text 3 能用支持的插件推荐</a></li>
<li><a href="http://blog.jobbole.com/82527/">Gif 多图：我常用的 16 个 Sublime Text 快捷键</a></li>
<li><a href="http://tutorial.jingwentian.com/Sublime-Text-3-Documentation/index.html">Sublime Text 3 文档</a></li>
<li><a href="https://www.zybuluo.com/king/note/47271">Sublime Text 3 配置和使用方法</a></li>
</ul>
]]></description><link>http://morning.work/page/2016-03/sublime-text-for-nodejs-es2015-development.html</link><guid isPermaLink="true">http://morning.work/page/2016-03/sublime-text-for-nodejs-es2015-development.html</guid><dc:creator><![CDATA[老雷]]></dc:creator><pubDate>Tue, 08 Mar 2016 00:00:00 GMT</pubDate></item><item><title><![CDATA[利用阿里云 OSS 搭建私有 Docker 仓库]]></title><description><![CDATA[<h2><a id="_2"></a>前言</h2>
<p>最近开始研究 Docker 的应用，于是打算 <strong>搭建一个私有的 Docker 仓库，并使用阿里云的 OSS 作为存储引擎</strong> 。从网上搜索到的资料大都是比较旧的，新版本的 Registry 服务与旧版本的差别比较大，瞎折腾了一天，踩坑无数。突然有感， <strong>网上的过时资料（或者说得不清不楚的）真是坑死人不偿命</strong> ，还是得把这两天摸索出来的门道记录下来，一是好让自己过一段时间后再部署 Docker 仓库时不用重踩一次坑，二来也顺便给后来者提个醒。</p>
<h2><a id="_7"></a>系统环境</h2>
<h3><a id="_docker__9"></a>客户端 docker 版本</h3>
<pre><code>docker version
Client:
 Version:      1.9.1
 API version:  1.21
 Go version:   go1.4.3
 Git commit:   a34a1d5
 Built:        Fri Nov 20 17:56:04 UTC 2015
 OS/Arch:      darwin/amd64

Server:
 Version:      1.9.1
 API version:  1.21
 Go version:   go1.4.3
 Git commit:   a34a1d5
 Built:        Fri Nov 20 17:56:04 UTC 2015
 OS/Arch:      linux/amd64
</code></pre>
<h3><a id="_docker__30"></a>服务器端 docker 版本</h3>
<pre><code>Boot2Docker version 1.9.1, build master : cef800b - Fri Nov 20 19:33:59 UTC 2015
Docker version 1.9.1, build a34a1d5
</code></pre>
<h3><a id="_dockercompose__37"></a>客户端 docker-compose 版本</h3>
<pre><code>docker-compose version 1.5.2, build 7240ff3
docker-py version: 1.5.0
CPython version: 2.7.9
OpenSSL version: OpenSSL 1.0.1j 15 Oct 2014
</code></pre>
<p>如果系统没有<code>docker-compose</code>命令，可以执行以下命令安装：</p>
<pre><code class="language-bash">$ curl -L https://github.com/docker/compose/releases/download/1.5.2/docker-compose-`uname <span class="hljs-_">-s</span>`-`uname -m` &gt; /usr/<span class="hljs-built_in">local</span>/bin/docker-compose
$ chmod +x /usr/<span class="hljs-built_in">local</span>/bin/docker-compose
</code></pre>
<h2><a id="_Registry__54"></a>启动 Registry 服务</h2>
<h3><a id="_56"></a>安装</h3>
<p>为了发挥 Docker 容器技术的优势，我们直接使用 Docker 镜像来部署服务。</p>
<p>首先在 <strong>服务器端</strong> 新建工作目录并进入该目录：</p>
<pre><code class="language-bash">$ mkdir my_registry &amp;&amp; <span class="hljs-built_in">cd</span> my_registry
</code></pre>
<p>在当前目录下新建文件<code>docker-compose.yml</code>：</p>
<pre><code>registry:
  restart: always
  image: &quot;registry:2&quot;
  ports:
    - 127.0.0.1:5000:5000
  volumes:
    - ./auth:/auth
    - ./data:/var/lib/registry
  environment:
    - REGISTRY_AUTH=htpasswd
    - REGISTRY_AUTH_HTPASSWD_REALM=Registry Realm
    - REGISTRY_AUTH_HTPASSWD_PATH=/auth/htpasswd
</code></pre>
<p>在启动 Registry 服务时，需要用到以下两个目录：</p>
<ul>
<li><code>auth</code>目录用于存放<code>docker login</code>时的账号和密码</li>
<li><code>data</code>目录用于存放<code>docker push</code>时上传上来的文件</li>
</ul>
<p>执行以下命令新建这两个目录：</p>
<pre><code class="language-bash">$ mkdir auth &amp;&amp; mkdir data
</code></pre>
<p>接着，创建一个测试账号（用户名：<code>test</code>，密码：<code>123456</code>）并保存到<code>auth/htpasswd</code>中：</p>
<pre><code class="language-bash">$ htpasswd -Bbn <span class="hljs-built_in">test</span> 123456 &gt; auth/htpasswd
</code></pre>
<p>现在我们来启动 Registry 服务：</p>
<pre><code class="language-bash">$ docker-compose up <span class="hljs-_">-d</span>
</code></pre>
<p>由于本地没有名为<code>registry:2</code>的镜像，控制台可能会打印出如下信息然后暂停一阵：</p>
<pre><code>Pulling registry (registry:2)...
</code></pre>
<p>稍等一两分钟，可以看到控制台打印出如下信息则说明已经启动成功了：</p>
<pre><code>Creating dockertest_registry_1
Attaching to dockertest_registry_1
registry_1 | time=&quot;2016-01-13T21:57:14Z&quot; level=warning msg=&quot;No HTTP secret provided - generated random secret. This may cause problems with uploads if multiple registries are behind a load-balancer. To provide a shared secret, fill in http.secret in the configuration file or set the REGISTRY_HTTP_SECRET environment variable.&quot; go.version=go1.5.2 instance.id=25aa4d1d-0510-4cb6-9006-1083bff5fc15 version=v2.2.1
registry_1 | time=&quot;2016-01-13T21:57:14Z&quot; level=info msg=&quot;redis not configured&quot; go.version=go1.5.2 instance.id=25aa4d1d-0510-4cb6-9006-1083bff5fc15 version=v2.2.1
registry_1 | time=&quot;2016-01-13T21:57:14Z&quot; level=info msg=&quot;using inmemory blob descriptor cache&quot; go.version=go1.5.2 instance.id=25aa4d1d-0510-4cb6-9006-1083bff5fc15 version=v2.2.1
registry_1 | time=&quot;2016-01-13T21:57:14Z&quot; level=info msg=&quot;Starting upload purge in 11m0s&quot; go.version=go1.5.2 instance.id=25aa4d1d-0510-4cb6-9006-1083bff5fc15 version=v2.2.1
registry_1 | time=&quot;2016-01-13T21:57:14Z&quot; level=info msg=&quot;listening on [::]:5000&quot; go.version=go1.5.2 instance.id=25aa4d1d-0510-4cb6-9006-1083bff5fc15 version=v2.2.1
</code></pre>
<h3><a id="_124"></a>测试</h3>
<p>现在再打开一个命令行窗口，并进入<code>my_registry</code>目录。</p>
<p>执行以下命令创建一个新镜像：</p>
<pre><code class="language-bash">$ docker tag registry:2 127.0.0.1:5000/<span class="hljs-built_in">test</span>/registry
</code></pre>
<p>说明：镜像名为<code>127.0.0.1:5000/test/registry</code>，其中<code>127.0.0.1:5000</code>表示服务器地址，<code>test/registry</code>表示镜像名。</p>
<p>上传之前要先登录：</p>
<pre><code class="language-bash">$ docker login 127.0.0.1:5000
</code></pre>
<p>说明：按提示输入上文创建的用户名和密码，邮箱可以不用填写。</p>
<p>登陆成功后，执行以下命令即可上传：</p>
<pre><code class="language-bash">$ docker push 127.0.0.1:5000/<span class="hljs-built_in">test</span>/registry
</code></pre>
<h2><a id="_OSS_151"></a>配置阿里云 OSS</h2>
<p>首先在刚才执行<code>docker-compose up</code>的命令行窗口中按<code>CTRL + C</code>退出服务。</p>
<p>将文件<code>docker-compose.yml</code>改为以下内容：</p>
<pre><code>registry:
  restart: always
  image: &quot;registry:2&quot;
  ports:
    - 127.0.0.1:5000:5000
  volumes:
    - ./auth:/auth
  environment:
    - REGISTRY_AUTH=htpasswd
    - REGISTRY_AUTH_HTPASSWD_REALM=Registry Realm
    - REGISTRY_AUTH_HTPASSWD_PATH=/auth/htpasswd
    - REGISTRY_STORAGE=oss
    - REGISTRY_STORAGE_OSS_ACCESSKEYID=your_oss_accesskey_id
    - REGISTRY_STORAGE_OSS_ACCESSKEYSECRET=your_oss_accesskey_secret
    - REGISTRY_STORAGE_OSS_REGION=your_oss_region
    - REGISTRY_STORAGE_OSS_BUCKET=your_oss_bucket
    - REGISTRY_STORAGE_OSS_ENDPOINT=your_oss_bucket.your_oss_region.aliyuncs.com
</code></pre>
<p>说明：由于使用阿里云 OSS 作为存储引擎，所以不需要再将文件存储到本地，因此将<code>volumes</code>中的<code>data</code>目录配置去掉；<code>environment</code>新增了<code>REGISTRY_STORAGE</code>系列的环境变量配置，需要将该部分的值替换为对应的<code>accesskey_id</code>、<code>accesskey_secret</code>、<code>region</code>、<code>bucket</code>和<code>endpoint</code>等信息。</p>
<p>删除<code>data</code>目录并重新启动服务：</p>
<pre><code class="language-bash">$ rm -Rf data &amp;&amp; docker-compose up
</code></pre>
<p>再执行刚才的命令上传镜像：</p>
<pre><code class="language-bash">$ docker push 127.0.0.1:5000/<span class="hljs-built_in">test</span>/registry
</code></pre>
<p>可以感觉到这次的上传速度没有第一次的快，因为它还需要上传到阿里云 OSS。待上传完毕，可以打开阿里云 OSS 的控制台界面检查文件是否被正确上传上去了。</p>
<h2><a id="_SSL__194"></a>配置 SSL 证书</h2>
<p>如果我们要在客户端（不是在服务器端测试）<code>pull</code>或<code>push</code>镜像时，<code>docker</code>使用的是<code>https</code>协议，因此会报<code>unable to ping registry endpoint</code>错误：</p>
<pre><code>The push refers to a repository [registry.example.com:5000/test] (len: 1)
unable to ping registry endpoint https://registry.example.com:5000/v0/
v2 ping attempt failed with error: Get https://registry.example.com:5000/v2/: dial tcp registry.example.com:5000: i/o timeout
 v1 ping attempt failed with error: Get https://registry.example.com:5000/v1/_ping: dial tcp 199.99.99.9:9000: i/o timeout
</code></pre>
<p>所以必须要配置 SSL 证书。</p>
<h3><a id="_207"></a>安装</h3>
<p>首先需要准备证书文件，分别保存到<code>auth/domain.crt</code>和<code>auth/domain.key</code>中。</p>
<p>新建 Nginx 的配置文件<code>auth/nginx.conf</code>：</p>
<pre><code>upstream docker-registry {
  server registry:5000;
}

## Set a variable to help us decide if we need to add the
## 'Docker-Distribution-Api-Version' header.
## The registry always sets this header.
## In the case of nginx performing auth, the header will be unset
## since nginx is auth-ing before proxying.
map $upstream_http_docker_distribution_api_version $docker_distribution_api_version {
  'registry/2.0' '';
  default registry/2.0;
}

server {
  listen 443 ssl;
  server_name myregistrydomain.com;

  # SSL
  ssl_certificate /etc/nginx/conf.d/domain.crt;
  ssl_certificate_key /etc/nginx/conf.d/domain.key;

  # Recommendations from https://raymii.org/s/tutorials/Strong_SSL_Security_On_nginx.html
  ssl_protocols TLSv1.1 TLSv1.2;
  ssl_ciphers 'EECDH+AESGCM:EDH+AESGCM:AES256+EECDH:AES256+EDH';
  ssl_prefer_server_ciphers on;
  ssl_session_cache shared:SSL:10m;

  # disable any limits to avoid HTTP 413 for large image uploads
  client_max_body_size 0;

  # required to avoid HTTP 411: see Issue #1486 (https://github.com/docker/docker/issues/1486)
  chunked_transfer_encoding on;

  location /v2/ {
    # Do not allow connections from docker 1.5 and earlier
    # docker pre-1.6.0 did not properly set the user agent on ping, catch &quot;Go *&quot; user agents
    if ($http_user_agent ~ &quot;^(docker\/1\.(3|4|5(?!\.[0-9]-dev))|Go ).*\$&quot; ) {
      return 404;
    }

    # To add basic authentication to v2 use auth_basic setting.
    auth_basic &quot;Registry realm&quot;;
    auth_basic_user_file /etc/nginx/conf.d/nginx.htpasswd;

    ## If $docker_distribution_api_version is empty, the header will not be added.
    ## See the map directive above where this variable is defined.
    add_header 'Docker-Distribution-Api-Version' $docker_distribution_api_version always;

    proxy_pass                          http://docker-registry;
    proxy_set_header  Host              \$http_host;   # required for docker client's sake
    proxy_set_header  X-Real-IP         \$remote_addr; # pass on real client's IP
    proxy_set_header  X-Forwarded-For   \$proxy_add_x_forwarded_for;
    proxy_set_header  X-Forwarded-Proto \$scheme;
    proxy_read_timeout                  900;
  }
}
</code></pre>
<p>将文件<code>docker-compose.yml</code>改为如下内容：</p>
<pre><code>nginx:
  image: &quot;nginx:1.9&quot;
  ports:
    - 443:443
  links:
    - registry:registry
  volumes:
    - ./auth/:/etc/nginx/conf.d

registry:
  restart: always
  image: &quot;registry:2&quot;
  ports:
    - 127.0.0.1:5000:5000
  environment:
    - REGISTRY_STORAGE=oss
    - REGISTRY_STORAGE_OSS_ACCESSKEYID=your_oss_accesskey_id
    - REGISTRY_STORAGE_OSS_ACCESSKEYSECRET=your_oss_accesskey_secret
    - REGISTRY_STORAGE_OSS_REGION=your_oss_region
    - REGISTRY_STORAGE_OSS_BUCKET=your_oss_bucket
    - REGISTRY_STORAGE_OSS_ENDPOINT=your_oss_bucket.your_oss_region.aliyuncs.com
</code></pre>
<p>说明：删除<code>registry</code>项目的<code>environment</code>中<code>REGISTRY_AUTH</code>开头的变量以及<code>volumes</code>项，因为<code>auth</code>认证已经在 Nginx 中配置了。</p>
<p>执行以下命令启动服务：</p>
<pre><code>$ docker-compose up
</code></pre>
<p>说明：如果本地不存在名为<code>nginx:1.9</code>的镜像，控制台可能会打印出<code>Pulling nginx (nginx:1.9)...</code>并先下载该镜像。</p>
<h3><a id="_309"></a>测试</h3>
<p>假设刚才配置的证书域名为<code>docker.ucdok.com</code>，现在我们 <strong>在客户端执行以下命令</strong> 登录：</p>
<pre><code class="language-bash">$ docker login docker.ucdok.com
</code></pre>
<p>生成新的镜像：</p>
<pre><code class="language-bash">$ docker pull ubuntu
$ docker tag ubuntu docker.ucdok.com/<span class="hljs-built_in">test</span>/ubuntu
</code></pre>
<p>上传新的镜像：</p>
<pre><code class="language-bash">$ docker push docker.ucdok.com/<span class="hljs-built_in">test</span>/ubuntu
</code></pre>
<h2><a id="_331"></a>其他问题</h2>
<h3><a id="_333"></a>增加用户</h3>
<p>可以执行<code>htpasswd</code>命令来创建，并将其保存到<code>auth/htpasswd</code>文件中：</p>
<pre><code>$ htpasswd -Bbn username password &gt;&gt; auth/htpasswd
</code></pre>
<h3><a id="_341"></a>在后台启动服务</h3>
<p>启动服务时增加<code>-d</code>参数：</p>
<pre><code class="language-bash">$ docker-compose up <span class="hljs-_">-d</span>
</code></pre>
<h3><a id="_349"></a>停止后台服务</h3>
<p>在<code>docker-compose.yml</code>文件所在目录执行以下命令：</p>
<pre><code>$ docker-compose stop
</code></pre>
<h2><a id="_358"></a>相关链接</h2>
<ul>
<li><a href="https://hub.docker.com/_/registry/">Containerized docker registry</a></li>
<li><a href="https://github.com/docker/compose/releases">docker-compose releases</a></li>
<li><a href="https://docs.docker.com/registry/deploying/">Deploying a registry server</a></li>
<li><a href="https://docs.docker.com/registry/nginx/#gotchas">Authenticating proxy with nginx</a></li>
<li><a href="https://docs.docker.com/compose/compose-file/">Compose file reference</a></li>
<li><a href="https://imququ.com/post/letsencrypt-certificate.html">Let's Encrypt，免费好用的 HTTPS 证书</a></li>
<li><a href="https://buy.wosign.com/free/">沃通免费 SSL 证书申请</a></li>
<li><a href="https://cnodejs.org/topic/5629c84ee6a3804c5815918d">Using Docker Compose in Node.js Project 中文翻译</a></li>
<li><a href="https://www.genedock.com/blog/2015/09/28/docker_private_registry/">在公有云上搭建负载均衡的 Docker 私有仓库</a></li>
</ul>
]]></description><link>http://morning.work/page/2016-01/deploying-your-own-private-docker-registry.html</link><guid isPermaLink="true">http://morning.work/page/2016-01/deploying-your-own-private-docker-registry.html</guid><dc:creator><![CDATA[老雷]]></dc:creator><pubDate>Thu, 14 Jan 2016 00:00:00 GMT</pubDate></item><item><title><![CDATA[在 CentOS 7 下安装配置 shadowsocks]]></title><description><![CDATA[<p>CentOS 7 开始默认使用<a href="https://en.wikipedia.org/wiki/Systemd">Systemd</a>作为开启启动脚本的管理工具，<a href="https://github.com/shadowsocks/">Shadowsocks</a>则是当前比较受欢迎的科学上网工具，本文将介绍如何在 CentOS 下安装和配置 Shadowsocks 服务。</p>
<h2><a id="_pip_4"></a>安装 pip</h2>
<p><a href="https://pip.pypa.io/en/stable/installing/">pip</a>是 python 的包管理工具。在本文中将使用 python 版本的 shadowsocks，此版本的 shadowsocks 已发布到 pip 上，因此我们需要通过 pip 命令来安装。</p>
<p>在控制台执行以下命令安装 pip：</p>
<pre><code class="language-bash">$ curl <span class="hljs-string">"https://bootstrap.pypa.io/get-pip.py"</span> -o <span class="hljs-string">"get-pip.py"</span>
$ python get-pip.py
</code></pre>
<h2><a id="_shadowsocks_15"></a>安装配置 shadowsocks</h2>
<p>在控制台执行以下命令安装 shadowsocks：</p>
<pre><code class="language-bash">$ pip install --upgrade pip
$ pip install shadowsocks
</code></pre>
<p>安装完成后，需要创建配置文件<code>/etc/shadowsocks.json</code>，内容如下：</p>
<pre><code class="language-json">{
  <span class="hljs-attr">"server"</span>: <span class="hljs-string">"0.0.0.0"</span>,
  <span class="hljs-attr">"server_port"</span>: <span class="hljs-number">8388</span>,
  <span class="hljs-attr">"password"</span>: <span class="hljs-string">"uzon57jd0v869t7w"</span>,
  <span class="hljs-attr">"method"</span>: <span class="hljs-string">"aes-256-cfb"</span>
}
</code></pre>
<p>说明：</p>
<ul>
<li><code>method</code>为加密方法，可选<code>aes-128-cfb, aes-192-cfb, aes-256-cfb, bf-cfb, cast5-cfb, des-cfb, rc4-md5, chacha20, salsa20, rc4, table</code></li>
<li><code>server_port</code>为服务监听端口</li>
<li><code>password</code>为密码，可使用<a href="http://ucdok.com/project/generate_password.html">密码生成工具</a>生成一个随机密码</li>
</ul>
<p>以上三项信息在配置 shadowsocks 客户端时需要配置一致，具体说明可查看 shadowsocks 的帮助文档。</p>
<h2><a id="_43"></a>配置自启动</h2>
<p>新建启动脚本文件<code>/etc/systemd/system/shadowsocks.service</code>，内容如下：</p>
<pre><code>[Unit]
Description=Shadowsocks

[Service]
TimeoutStartSec=0
ExecStart=/usr/bin/ssserver -c /etc/shadowsocks.json

[Install]
WantedBy=multi-user.target
</code></pre>
<p>执行以下命令启动 shadowsocks 服务：</p>
<pre><code class="language-bash">$ systemctl <span class="hljs-built_in">enable</span> shadowsocks
$ systemctl start shadowsocks
</code></pre>
<p>为了检查 shadowsocks 服务是否已成功启动，可以执行以下命令查看服务的状态：</p>
<pre><code class="language-bash">$ systemctl status shadowsocks <span class="hljs-_">-l</span>
</code></pre>
<p>如果服务启动成功，则控制台显示的信息可能类似这样：</p>
<pre><code>● shadowsocks.service - Shadowsocks
   Loaded: loaded (/etc/systemd/system/shadowsocks.service; enabled; vendor preset: disabled)
   Active: active (running) since Mon 2015-12-21 23:51:48 CST; 11min ago
 Main PID: 19334 (ssserver)
   CGroup: /system.slice/shadowsocks.service
           └─19334 /usr/bin/python /usr/bin/ssserver -c /etc/shadowsocks.json

Dec 21 23:51:48 morning.work systemd[1]: Started Shadowsocks.
Dec 21 23:51:48 morning.work systemd[1]: Starting Shadowsocks...
Dec 21 23:51:48 morning.work ssserver[19334]: INFO: loading config from /etc/shadowsocks.json
Dec 21 23:51:48 morning.work ssserver[19334]: 2015-12-21 23:51:48 INFO     loading libcrypto from libcrypto.so.10
Dec 21 23:51:48 morning.work ssserver[19334]: 2015-12-21 23:51:48 INFO     starting server at 0.0.0.0:8388
</code></pre>
<h2><a id="_89"></a>一键安装脚本</h2>
<p>新建文件<code>install-shadowsocks.sh</code>，内容如下：</p>
<pre><code class="language-bash"><span class="hljs-meta">#!/bin/bash</span>
<span class="hljs-comment"># Install Shadowsocks on CentOS 7</span>

<span class="hljs-built_in">echo</span> <span class="hljs-string">"Installing Shadowsocks..."</span>

random-<span class="hljs-function"><span class="hljs-title">string</span></span>()
{
    cat /dev/urandom | tr -dc <span class="hljs-string">'a-zA-Z0-9'</span> | fold -w <span class="hljs-variable">${1:-32}</span> | head -n 1
}

CONFIG_FILE=/etc/shadowsocks.json
SERVICE_FILE=/etc/systemd/system/shadowsocks.service
SS_PASSWORD=$(random-string 32)
SS_PORT=8388
SS_METHOD=aes-256-cfb
SS_IP=`ip route get 1 | awk <span class="hljs-string">'{print $NF;exit}'</span>`
GET_PIP_FILE=/tmp/get-pip.py

<span class="hljs-comment"># install pip</span>
curl <span class="hljs-string">"https://bootstrap.pypa.io/get-pip.py"</span> -o <span class="hljs-string">"<span class="hljs-variable">${GET_PIP_FILE}</span>"</span>
python <span class="hljs-variable">${GET_PIP_FILE}</span>

<span class="hljs-comment"># install shadowsocks</span>
pip install --upgrade pip
pip install shadowsocks

<span class="hljs-comment"># create shadowsocls config</span>
cat &lt;&lt;EOF | sudo tee <span class="hljs-variable">${CONFIG_FILE}</span>
{
  <span class="hljs-string">"server"</span>: <span class="hljs-string">"0.0.0.0"</span>,
  <span class="hljs-string">"server_port"</span>: <span class="hljs-variable">${SS_PORT}</span>,
  <span class="hljs-string">"password"</span>: <span class="hljs-string">"<span class="hljs-variable">${SS_PASSWORD}</span>"</span>,
  <span class="hljs-string">"method"</span>: <span class="hljs-string">"<span class="hljs-variable">${SS_METHOD}</span>"</span>
}
EOF

<span class="hljs-comment"># create service</span>
cat &lt;&lt;EOF | sudo tee <span class="hljs-variable">${SERVICE_FILE}</span>
[Unit]
Description=Shadowsocks

[Service]
TimeoutStartSec=0
ExecStart=/usr/bin/ssserver -c <span class="hljs-variable">${CONFIG_FILE}</span>

[Install]
WantedBy=multi-user.target
EOF

<span class="hljs-comment"># start service</span>
systemctl <span class="hljs-built_in">enable</span> shadowsocks
systemctl start shadowsocks

<span class="hljs-comment"># view service status</span>
sleep 5
systemctl status shadowsocks <span class="hljs-_">-l</span>

<span class="hljs-built_in">echo</span> <span class="hljs-string">"================================"</span>
<span class="hljs-built_in">echo</span> <span class="hljs-string">""</span>
<span class="hljs-built_in">echo</span> <span class="hljs-string">"Congratulations! Shadowsocks has been installed on your system."</span>
<span class="hljs-built_in">echo</span> <span class="hljs-string">"You shadowsocks connection info:"</span>
<span class="hljs-built_in">echo</span> <span class="hljs-string">"--------------------------------"</span>
<span class="hljs-built_in">echo</span> <span class="hljs-string">"server:      <span class="hljs-variable">${SS_IP}</span>"</span>
<span class="hljs-built_in">echo</span> <span class="hljs-string">"server_port: <span class="hljs-variable">${SS_PORT}</span>"</span>
<span class="hljs-built_in">echo</span> <span class="hljs-string">"password:    <span class="hljs-variable">${SS_PASSWORD}</span>"</span>
<span class="hljs-built_in">echo</span> <span class="hljs-string">"method:      <span class="hljs-variable">${SS_METHOD}</span>"</span>
<span class="hljs-built_in">echo</span> <span class="hljs-string">"--------------------------------"</span>
</code></pre>
<p>执行以下命令一键安装：</p>
<pre><code class="language-bash">$ chmod +x install-shadowsocks.sh
$ ./install-shadowsocks.sh
</code></pre>
<p>也可以直接执行以下命令从 GitHub 下载安装脚本并执行：</p>
<pre><code class="language-bash">$ bash &lt;(curl <span class="hljs-_">-s</span> http://morning.work/examples/2015-12/install-shadowsocks.sh)
</code></pre>
<p>安装完成后会自动打印出 Shadowsocks 的连接配置信息。比如：</p>
<pre><code>Congratulations! Shadowsocks has been installed on your system.
You shadowsocks connection info:
--------------------------------
server:      10.0.2.15
server_port: 8388
password:    RaskAAcW0IQrVcA7n0QLCEphhng7K4Yc
method:      aes-256-cfb
--------------------------------
</code></pre>
<h2><a id="_189"></a>扩展阅读</h2>
<ul>
<li><a href="https://blog.linuxeye.com/400.html">systemd 详解</a></li>
<li><a href="https://pip.pypa.io/en/stable/installing/">Install pip</a></li>
<li><a href="http://www.liquidweb.com/kb/how-to-install-pip-on-centos-7/">How to Install Pip on CentOS 7</a></li>
<li><a href="https://scottlinux.com/2014/12/08/how-to-create-a-systemd-service-in-linux-centos-7/">How To Create a systemd Service in Linux (CentOS 7)</a></li>
<li><a href="https://coreos.com/docs/launching-containers/launching/getting-started-with-systemd/">Getting Started with systemd</a></li>
<li><a href="http://stackoverflow.com/questions/13322485/how-to-i-get-the-primary-ip-address-of-the-local-machine-on-linux-and-os-x">How to I get the primary IP address of the local machine on Linux and OS X?</a></li>
<li><a href="http://stackoverflow.com/questions/5735666/execute-bash-script-from-url">Execute bash script from URL</a></li>
</ul>
]]></description><link>http://morning.work/page/2015-12/install-shadowsocks-on-centos-7.html</link><guid isPermaLink="true">http://morning.work/page/2015-12/install-shadowsocks-on-centos-7.html</guid><dc:creator><![CDATA[老雷]]></dc:creator><pubDate>Tue, 22 Dec 2015 00:00:00 GMT</pubDate></item><item><title><![CDATA[ES2015 & babel 实战：开发 NPM 模块]]></title><description><![CDATA[<h2><a id="_3"></a>前言</h2>
<p>近一年来，JavaScript 界关于 ES6（ECMAScript 6，本文简称 ES6）的讨论越来激烈，作为未来要统一全宇宙的语言（<strong>PHP 是世界上最好的语言，但 JavaScript 终将统一全宇宙</strong>），JavaScript 的运行环境众多，对 ECMAScript 标准的支持程度不一，所以对于 ES6 我一直处于观望状态。</p>
<p>前不久 ES6 标准正式发布，而 Node.js 也在最近刚刚发布了 5.1.0 版本，对 ES6 标准的支持也越来越完善，babel（一个将 ES6/ES7 写的代码转换为 ES5 代码的编译器）也发布了 6.0 版本，近期也涌现出了不少好文章（比如<a href="http://lifemap.in/">小问</a>写的<a href="http://gank.io/post/564151c1f1df1210001c9161">「给 JavaScript 初心者的 ES2015 实战」</a>），种种迹象表明 ES6 真的要火了，而我也终于按耐不住了……</p>
<p>这几天正在写一个<a href="https://github.com/leizongmin/node-lei-download">方便下载文件的模块</a>（可以得到下载进度信息），正好可以使用 ES6 新语法特性来改写，作为我写下的第一个使用 ES6 语法的 NPM 模块。本文内容将分为以下几部分：</p>
<ul>
<li>配置 babel 编译环境</li>
<li>编写模块</li>
<li>单元测试</li>
<li>发布模块</li>
</ul>
<p>本文的重点是介绍借助 babel 开发 Node.js 项目的基本方法，同时会简略介绍文中出现的 ES2015 新语法，具体介绍可阅读<a href="http://www.ruanyifeng.com">阮一峰</a>所著的<a href="http://es6.ruanyifeng.com/">「ECMAScript 6 入门」</a>或 babel 官方文档中的<a href="http://babeljs.io/docs/learn-es2015/">「Learn ES2015」</a>。</p>
<p>babel 官方提供了一个<a href="http://babeljs.io/repl">在线 REPL</a>，可以实时输出转换后的 JavaScript 代码，并且看到其运行结果，对于初学者尤为有用。访问网址 <a href="http://babeljs.io/repl">http://babeljs.io/repl</a> ，其界面如下：</p>
<p><img src="../../images/2015-11/babel_online_repl.jpg" alt="babel online repl"></p>
<p>说明：使用时勾选左边的<code>Experimental</code>可使用最新的语法特性。</p>
<h2><a id="_25"></a>软件环境</h2>
<p>由于相关软件和模块正处于高速发展期，无法保证你阅读这篇文章的时候还能照着一步一步<strong>准确无误</strong>地运行下去，以下列出在编写本文时所用到的软件和模块的版本：</p>
<ul>
<li><strong>Node.js</strong> <code>v5.1.0</code></li>
<li><strong>npm</strong> <code>3.3.12</code></li>
<li><strong>babel</strong> <code>6.2.0 (babel-core 6.2.1)</code></li>
<li><strong>mocha</strong> <code>2.3.4</code></li>
</ul>
<h2><a id="_babel__34"></a>配置 babel 编译环境</h2>
<h3><a id="1_babel_36"></a>1、安装 babel</h3>
<blockquote>
<p>Babel is a JavaScript compiler. Use next generation JavaScript, today</p>
</blockquote>
<p>目前最新版的 Node.js（v5.1.0）还未完全支持 ES2015 的新语法特性，而且我们编写的模块可能要在 Node v0.12.x 或更低版本下运行，因此需要借助 babel 将 ES2015 标准的 JavaScript 程序转换成 ES5 标准的。</p>
<p>执行以下命令安装 babel：</p>
<pre><code class="language-bash">$ npm i -g babel-cli
</code></pre>
<p>由于 babel 依赖的模块比较多，可能会花费比较长的时间甚至安装不成功，可以尝试使用 cnpmjs 的 NPM 镜像，比如（简单在安装命令末尾添加<code>--registry=http://registry.npm.taobao.org</code>）：</p>
<pre><code class="language-bash">$ npm i -g babel-cli --registry=http://registry.npm.taobao.org
</code></pre>
<p><a href="http://cnpmjs.org/">cnpmjs</a>镜像的详细介绍可访问其官网：<a href="http://cnpmjs.org/">http://cnpmjs.org/</a></p>
<p>安装完成后，系统将获得以下两个命令：</p>
<ul>
<li><code>babel</code> 编译器</li>
<li><code>babel-node</code> 可以直接运行 ES2015 程序的 Node 命令</li>
</ul>
<p><code>babel-cli</code>的详细用法可以参考其文档：<a href="https://babeljs.io/docs/usage/cli/">https://babeljs.io/docs/usage/cli/</a></p>
<h3><a id="2_63"></a>2、初始化项目</h3>
<p>执行以下命令初始化项目（执行<code>npm init</code>时需要按提示输入相应信息，可直接按回车跳过）：</p>
<pre><code class="language-bash">$ mkdir es2015_demo &amp;&amp; <span class="hljs-built_in">cd</span> es2015_demo &amp;&amp; git init &amp;&amp; npm init
</code></pre>
<p>现在我们新建一个文件<code>test.js</code>试试是否能正常运行：</p>
<pre><code class="language-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sleep</span>(<span class="hljs-params">ms = 0</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>((resolve, reject) =&gt; setTimeout(resolve, ms));
}

<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) {
    <span class="hljs-keyword">await</span> sleep(<span class="hljs-number">500</span>);
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`i=<span class="hljs-subst">${i}</span>`</span>);
  }
}

test().then(() =&gt; <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'done'</span>));
</code></pre>
<p>执行以下命令运行<code>test.js</code>：</p>
<pre><code class="language-bash">$ babel-node test.js
</code></pre>
<p>在我本机的环境下显示以下错误信息：</p>
<pre><code>/usr/local/lib/node_modules/babel-cli/node_modules/babel-core/lib/transformation/file/index.js:540
      throw err;
      ^

SyntaxError: /private/tmp/es2015_demo/test.js: Unexpected token (5:6)
  3 | }
  4 |
&gt; 5 | async function test() {
    |       ^
  6 |   for (let i = 0; i &lt; 10; i++) {
  7 |     await sleep(500);
  8 |     console.log(`i=${i}`);

...
</code></pre>
<p>由提示信息可判断出，应该是不支持<code>async function</code>导致的，因为这是 ES7 标准中定义的新语法，需要配置相应的 babel 插件才能支持它。本文为了方面使用最新的 JavaScript 语法，暂时不考虑 babel 的编译性能，直接开启所有可能用到的插件，具体可以自行研究 babel 的官方文档。</p>
<p>新建文件<code>.babelrc</code>：</p>
<pre><code class="language-json">{
  <span class="hljs-attr">"presets"</span>: [<span class="hljs-string">"es2015"</span>, <span class="hljs-string">"stage-0"</span>]
}
</code></pre>
<p><code>.babelrc</code>为 babel 的配置文件，保存在项目的根目录下，其中<code>presets</code>用于设置开启的语法特性集合，详细介绍可参考官方文档：<a href="https://babeljs.io/docs/usage/babelrc/">https://babeljs.io/docs/usage/babelrc/</a> 和 <a href="http://babeljs.io/docs/plugins/#presets">http://babeljs.io/docs/plugins/#presets</a></p>
<p>接下来我们还需要安装插件依赖的模块，执行以下命令安装并保存到<code>package.json</code>的<code>devDependencies</code>中：</p>
<pre><code class="language-bash">$ npm i babel-preset-es2015 babel-preset-stage-0 --save-dev
</code></pre>
<p>现在再重新执行<code>test.js</code>，可看到控制台每隔 500ms 打印出一行，直到输出<code>done</code>时结束：</p>
<pre><code class="language-bash">$ babel-node test.js

i=0
i=1
i=2
i=3
i=4
i=5
i=6
i=7
i=8
i=9
<span class="hljs-keyword">done</span>
</code></pre>
<h3><a id="3_149"></a>3、编译程序</h3>
<p>在发布项目时，要求可以在不依赖 babel 编译器的环境下运行，因此我们需要将 ES2015 的程序编译成 ES5 的：</p>
<pre><code class="language-bash">$ babel test.js --out-file test.compiled.js
</code></pre>
<p>执行上面的命令后，生成了编译后的文件<code>test.compiled.js</code>，我们尝试执行它看看：</p>
<pre><code class="language-bash">$ node test.compiled.js
</code></pre>
<p>在我的系统环境下提示以下出错信息：</p>
<pre><code>/private/tmp/es2015_demo/test.compiled.js:4
  var ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee() {
                              ^

ReferenceError: regeneratorRuntime is not defined
    at /private/tmp/es2015_demo/test.compiled.js:4:31

...
</code></pre>
<p>经阅读官方文档可知，编译后的 JavaScript 程序有时候需要依赖一些运行时<code>polyfill</code>，通过安装<code>babel-polyfill</code>模块来获得：</p>
<pre><code class="language-bash">$ npm i babel-polyfill --save
</code></pre>
<p>然后，我们需要修改编译后的文件<code>test.compiled.js</code>，在其首行加上以下代码来载入<code>babel-polyfill</code>：</p>
<pre><code class="language-javascript"><span class="hljs-built_in">require</span>(<span class="hljs-string">'babel-polyfill'</span>);
</code></pre>
<p>再次执行<code>test.compiled.js</code>便可看到与<code>$ babel-node test.js</code>一样的结果。</p>
<p><code>polyfill</code>的详细介绍可参考官方文档：<a href="http://babeljs.io/docs/usage/polyfill/">http://babeljs.io/docs/usage/polyfill/</a></p>
<p>至此，我们已经配置了一个能使用 ES2015 语法的 Node.js 运行环境了。</p>
<h2><a id="_195"></a>编写模块</h2>
<h3><a id="1_197"></a>1、功能描述</h3>
<p>本文以<a href="https://github.com/leizongmin/node-lei-download">lei-download</a>模块为例，该模块是一个主要功能是根据一个 URL 来下载文件到本地，或者本地直接文件的复制，同时提供下载/复制进度信息。其使用方法如下：</p>
<pre><code class="language-javascript"><span class="hljs-keyword">let</span> download = <span class="hljs-built_in">require</span>(<span class="hljs-string">'lei-download'</span>);

<span class="hljs-keyword">let</span> source = <span class="hljs-string">'一个 URL 或者本地文件名'</span>;
<span class="hljs-keyword">let</span> target = <span class="hljs-string">'要存储到的本地位置，null|false|undefined 表示自动生成一个临时文件'</span>;
<span class="hljs-comment">// 用于获取进度通知的函数，可以省略</span>
<span class="hljs-keyword">let</span> progress = (size, total) =&gt; <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`进度：<span class="hljs-subst">${size}</span>/<span class="hljs-subst">${total}</span>`</span>);

download(source, target, progress)
  .then(filename =&gt; <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`已保存到：<span class="hljs-subst">${filename}</span>`</span>))
  .catch(err =&gt; <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`出错：<span class="hljs-subst">${err}</span>`</span>));

<span class="hljs-comment">// 也可以使用 callback 模式</span>
download(source, target, progress, (err, filename) =&gt; {
  <span class="hljs-keyword">if</span> (err) <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`出错：<span class="hljs-subst">${err}</span>`</span>);
  <span class="hljs-keyword">else</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`已保存到：<span class="hljs-subst">${filename}</span>`</span>);
});
</code></pre>
<p>在编写模块时，我们首先要实现以下两个函数的功能：</p>
<ul>
<li><code>downloadFile(source, target, progress)</code> 从一个 URL 下载文件并保存到本地</li>
<li><code>copyFile(source, target, progress)</code> 复制一个本地文件</li>
</ul>
<p>然后再编写一个<code>download()</code>函数来判断<code>source</code>参数，并选择使用<code>downloadFile()</code>或者<code>copyFile()</code>来完成请求。</p>
<h3><a id="2_227"></a>2、编写程序</h3>
<p>在本项目中，所有的 ES2015 源程序均保存在<code>src</code>目录下，发布项目时会执行相应的命令将其编译并输出到<code>lib</code>目录，具体方法在 <strong>「发布模块」</strong> 小节中介绍。</p>
<p>实现<code>copyFile()</code>函数，新建文件<code>src/copy.js</code>：</p>
<pre><code class="language-javascript"><span class="hljs-keyword">import</span> fs <span class="hljs-keyword">from</span> <span class="hljs-string">'fs'</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">copyFile</span>(<span class="hljs-params">source, target, progress</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>((resolve, reject) =&gt; {

    fs.stat(source, (err, stats) =&gt; {
      <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">return</span> reject(err);

      <span class="hljs-keyword">let</span> ss = fs.createReadStream(source);
      <span class="hljs-keyword">let</span> ts = fs.createWriteStream(target);
      ss.on(<span class="hljs-string">'error'</span>, reject);
      ts.on(<span class="hljs-string">'error'</span>, reject);

      <span class="hljs-keyword">let</span> copySize = <span class="hljs-number">0</span>;
      ss.on(<span class="hljs-string">'data'</span>, data =&gt; {
        copySize += data.length;
        progress &amp;&amp; progress(copySize, stats.size);
      });

      ss.on(<span class="hljs-string">'end'</span>, () =&gt; resolve(target));

      ss.pipe(ts);
    });

  });
}
</code></pre>
<p>说明：</p>
<ul>
<li><code>import fs from 'fs'</code>为 ES2015 模块系统加载模块的方式，可理解为<code>var fs = require('fs')</code>，具体在下文「模块系统」一节中介绍。</li>
<li>通过<code>fs.createReadStream(source)</code>和<code>fs.createWriteStream(target)</code>来创建读取文件流和写入文件流，并监听读取文件流的<code>data</code>事件获得当前进度信息。</li>
<li><code>export default function copyFile() {}</code>将函数<code>copyFile()</code>作为模块输出，相当于<code>module.exports = function copyFile() {}</code>，具体在下文「模块系统」一节中介绍。</li>
<li>函数执行后返回一个<code>Promise</code>对象，通过其<code>.then()</code>和<code>.catch()</code>来获取执行结果，关于 Promise 的详细介绍可阅读<a href="http://www.ruanyifeng.com">阮一峰</a>所著的<a href="http://es6.ruanyifeng.com/">「ECMAScript 6 入门 」</a>中<a href="http://es6.ruanyifeng.com/#docs/promise">「 Promise 对象」</a>一章。</li>
</ul>
<p>为了测试该代码能否正常工作，可在文件末尾增加以下测试程序（在编写单元测试时将删除）：</p>
<pre><code class="language-javascript">copyFile(__filename, <span class="hljs-string">'/tmp/copy.js'</span>, (size, total) =&gt; <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`进度<span class="hljs-subst">${size}</span>/<span class="hljs-subst">${total}</span>`</span>))
  .then(filename =&gt; <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`已保存到<span class="hljs-subst">${filename}</span>`</span>))
  .catch(err =&gt; <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`出错：<span class="hljs-subst">${err}</span>`</span>));
</code></pre>
<p>以上程序的作用是将当前 JavaScript 文件复制到<code>/tmp/copy.js</code>，使用<code>babel-node</code>执行该文件将得到以下结果：</p>
<pre><code class="language-bash">$ babel-node src/copy.js

进度 749/749
已保存到/tmp/copy.js
</code></pre>
<p>实现<code>downloadFile()</code>函数，新建文件<code>src/download.js</code>：</p>
<pre><code class="language-javascript"><span class="hljs-keyword">import</span> fs <span class="hljs-keyword">from</span> <span class="hljs-string">'fs'</span>;
<span class="hljs-keyword">import</span> request <span class="hljs-keyword">from</span> <span class="hljs-string">'request'</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">downloadFile</span>(<span class="hljs-params">url, target, progress</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>((resolve, reject) =&gt; {

    <span class="hljs-keyword">let</span> s = fs.createWriteStream(target);
    s.on(<span class="hljs-string">'error'</span>, reject);

    <span class="hljs-keyword">let</span> totalSize = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">let</span> downloadSize = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">let</span> req = request
      .get({
        url: url,
        encoding: <span class="hljs-literal">null</span>
      })
      .on(<span class="hljs-string">'response'</span>, res =&gt; {
        <span class="hljs-keyword">if</span> (res.statusCode !== <span class="hljs-number">200</span>) {
          <span class="hljs-keyword">return</span> reject(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'status #'</span> + res.statusCode));
        }
        totalSize = <span class="hljs-built_in">Number</span>(res.headers[<span class="hljs-string">'content-length'</span>]) || <span class="hljs-literal">null</span>;

        res.on(<span class="hljs-string">'data'</span>, data =&gt; {
          downloadSize += data.length;
          progress &amp;&amp; progress(downloadSize, totalSize);
        });
        res.on(<span class="hljs-string">'end'</span>, () =&gt; resolve(target));
      })
      .pipe(s);

  });
}
</code></pre>
<p>说明：</p>
<ul>
<li>程序使用<code>request</code>模块来下载 URL 的内容，使用时执行命令<code>$ npm i request --save</code>安装该模块。</li>
<li>通过<code>request</code>模块的<code>pipe()</code>方法将收到的数据写入到<code>fs.createWriteStream(target)</code>创建的写入文件流中，<code>request</code>模块的详细使用方法可参考其文档：<a href="https://www.npmjs.com/package/request">https://www.npmjs.com/package/request</a></li>
</ul>
<p>为了测试该代码能否正常工作，可在文件末尾增加以下测试程序（在编写单元测试时将删除）：</p>
<pre><code class="language-javascript"><span class="hljs-keyword">let</span> url = <span class="hljs-string">'http://dn-cnodestatic.qbox.me/public/images/cnodejs_light.svg'</span>;
downloadFile(url, <span class="hljs-string">'/tmp/avatar.jpg'</span>, (size, total) =&gt; <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`进度<span class="hljs-subst">${size}</span>/<span class="hljs-subst">${total}</span>`</span>))
  .then(filename =&gt; <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`已保存到<span class="hljs-subst">${filename}</span>`</span>))
  .catch(err =&gt; <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`出错：<span class="hljs-subst">${err}</span>`</span>));
</code></pre>
<p>以上程序的作用是将 URL 为<code>http://dn-cnodestatic.qbox.me/public/images/cnodejs_light.svg</code>的文件复制到<code>/tmp/avatar.jpg</code>，使用<code>babel-node</code>执行该文件将得到以下结果：</p>
<pre><code class="language-bash">$ babel-node src/download.js

进度 5944/5944
已保存到/tmp/avatar.jpg
</code></pre>
<p>实现<code>download()</code>函数，新建文件<code>src/index.js</code>：</p>
<pre><code class="language-javascript"><span class="hljs-keyword">import</span> os <span class="hljs-keyword">from</span> <span class="hljs-string">'os'</span>;
<span class="hljs-keyword">import</span> path <span class="hljs-keyword">from</span> <span class="hljs-string">'path'</span>;
<span class="hljs-keyword">import</span> mkdirp <span class="hljs-keyword">from</span> <span class="hljs-string">'mkdirp'</span>;
<span class="hljs-keyword">import</span> copyFile <span class="hljs-keyword">from</span> <span class="hljs-string">'./copy'</span>;
<span class="hljs-keyword">import</span> downloadFile <span class="hljs-keyword">from</span> <span class="hljs-string">'./download'</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">download</span>(<span class="hljs-params">source, target, progress</span>) </span>{
  target = target || randomFilename(download.tmpDir);
  progress = progress || noop;
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>((resolve, reject) =&gt; {

    mkdirp(path.dirname(target), err =&gt; {
      <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">return</span> callback(err);

      resolve((isURL(source) ? downloadFile : copyFile)
        (source, target, progress));
    });

  });
}

<span class="hljs-keyword">let</span> getTmpDir = os.tmpdir || os.tmpDir;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">randomString</span>(<span class="hljs-params">size = 6, chars = 'abcdefghijklmnopqrstuvwxyz0123456789'</span>) </span>{
  <span class="hljs-keyword">let</span> max = chars.length + <span class="hljs-number">1</span>;
  <span class="hljs-keyword">let</span> str = <span class="hljs-string">''</span>;
  <span class="hljs-keyword">while</span> (size &gt; <span class="hljs-number">0</span>) {
    str += chars.charAt(<span class="hljs-built_in">Math</span>.floor(<span class="hljs-built_in">Math</span>.random() * max));
    size--;
  }
  <span class="hljs-keyword">return</span> str;
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">randomFilename</span>(<span class="hljs-params">tmpDir = getTmpDir(</span>)) </span>{
  <span class="hljs-keyword">return</span> path.resolve(tmpDir, randomString(<span class="hljs-number">20</span>));
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isURL</span> (<span class="hljs-params">url</span>) </span>{
  <span class="hljs-keyword">if</span> (url.substr(<span class="hljs-number">0</span>, <span class="hljs-number">7</span>) === <span class="hljs-string">'http://'</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
  <span class="hljs-keyword">if</span> (url.substr(<span class="hljs-number">0</span>, <span class="hljs-number">8</span>) === <span class="hljs-string">'https://'</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
}

<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">noop</span>(<span class="hljs-params"></span>) </span>{ }
</code></pre>
<p>说明：</p>
<ul>
<li><code>import copyFile from './copy'</code>用于载入模块，相当于<code>var copyFile = require('./copy')</code>。</li>
<li><code>download(...args)</code>函数中的<code>...args</code>相当于<code>var args = Array.prototype.call(arguments);</code>。</li>
<li>程序使用<code>mkdirp</code>模块来创建目标文件的上级目录，使用时执行命令<code>$ npm i mkdirp --save</code>安装该模块。</li>
<li><code>getTmpDir()</code>函数用于取得当前系统的临时目录，通过<code>os.tmpDir()</code>获得。</li>
<li><code>randomString(size)</code>函数用于生成指定长度的随机字符串。</li>
<li><code>randomFilename(tmpDir)</code>用于生成临时文件名，默认存储在系统临时目录下，可通过<code>tmpDir</code>参数指定。</li>
<li><code>isURL(url)</code>函数用于判断参数是否为一个 URL。</li>
</ul>
<p>为了验证程序是否正确，我们可以将上文的<code>src/copy.js</code>和<code>src/download.js</code>中的测试程序放到<code>src/index.js</code>文件的末尾并执行（需要将旧的程序程序删除），比如：</p>
<pre><code class="language-javascript">download(__filename, <span class="hljs-string">'/tmp/copy.js'</span>, (size, total) =&gt; <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`进度<span class="hljs-subst">${size}</span>/<span class="hljs-subst">${total}</span>`</span>))
  .then(filename =&gt; <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`已保存到<span class="hljs-subst">${filename}</span>`</span>))
  .catch(err =&gt; <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`出错：<span class="hljs-subst">${err}</span>`</span>));
</code></pre>
<p>正常情况下，其执行结果应该跟上文中的结果是一致的。</p>
<h3><a id="3_415"></a>3、模块系统</h3>
<p>Node.js 使用的是 CommonJS 模块系统，模块的输出我们一般通过给<code>exports</code>对象设置属性来做：</p>
<pre><code class="language-javascript"><span class="hljs-comment">// 输出变量或函数</span>
exports.x = <span class="hljs-number">123</span>;
exports.y = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'hello'</span>);
};
</code></pre>
<p>可以通过以下方式来操作：</p>
<pre><code class="language-javascript"><span class="hljs-keyword">var</span> mod = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./my_module'</span>);

<span class="hljs-built_in">console</span>.log(mod.x);
mod.y();
</code></pre>
<p>也可以通过覆盖<code>module.exports</code>来输出一个函数或者其他数据类型：</p>
<pre><code class="language-javascript"><span class="hljs-built_in">module</span>.exports = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'hello'</span>);
};
</code></pre>
<p>通过以下方式来操作：</p>
<pre><code class="language-javascript"><span class="hljs-keyword">var</span> fn = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./my_module'</span>);

fn();
</code></pre>
<p>而在 ES2015 中，模块通过<code>export</code>语句来输出：</p>
<pre><code class="language-javascript"><span class="hljs-comment">// 普通输出，相当于 exports.x = y;</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> a = <span class="hljs-number">123</span>;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">var</span> b = <span class="hljs-number">456</span>;
<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">c</span>(<span class="hljs-params"></span>) </span>{ }
<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">d</span> </span>{ }

<span class="hljs-comment">// 默认输出，相当于 module.exports = z;</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">y</span>(<span class="hljs-params"></span>) </span>{ }
</code></pre>
<p>通过<code>import</code>语句来引入模块，不同的引入方式其含义是不一样的，比如：</p>
<pre><code class="language-javascript"><span class="hljs-comment">// 操作 export var x = y 方式的输出</span>
<span class="hljs-keyword">import</span> {a, b, c, d} <span class="hljs-keyword">from</span> <span class="hljs-string">'./my_module'</span>;
<span class="hljs-comment">// 通过相应的变量名称 a, b, c, d 来操作</span>

<span class="hljs-comment">// 或者将所有输出指向一个对象</span>
<span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> mod <span class="hljs-keyword">from</span> <span class="hljs-string">'./my_module'</span>;
<span class="hljs-comment">// 通过 mod.a, mod.b, mod.c, mod.d 来操作</span>

<span class="hljs-comment">// 操作 export default x 方式的输出</span>
<span class="hljs-keyword">import</span> y <span class="hljs-keyword">from</span> <span class="hljs-string">'./my_module'</span>;
</code></pre>
<p>对于非 ES2015 程序输出的模块，<code>import * as mod</code>和<code>import mod</code>其结果是一样的，比如：</p>
<pre><code>import * as fs1 from 'fs';
import fs2 from 'fs';

// fs1.readFile() 和 fs2.readFile() 是一样的
</code></pre>
<p>为了更容易理解 ES2015 的模块系统原理，我们可以通过阅读编译后的 JavaScript 程序来了解。访问<a href="http://babeljs.io/repl/">babel 的在线 REPL</a>或将程序保存到本地，并执行<code>babel file.js</code>来查看编译后的程序。</p>
<p>以下 ES2015 代码：</p>
<pre><code class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> a = <span class="hljs-number">123</span>;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">var</span> b = <span class="hljs-number">456</span>;
<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">c</span>(<span class="hljs-params"></span>) </span>{ }
<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">d</span> </span>{ }

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">y</span>(<span class="hljs-params"></span>) </span>{ }
</code></pre>
<p>编译后结果如下：</p>
<pre><code class="language-javascript"><span class="hljs-meta">"use strict"</span>;

<span class="hljs-built_in">Object</span>.defineProperty(exports, <span class="hljs-string">"__esModule"</span>, {
  value: <span class="hljs-literal">true</span>
});
exports.c = c;
exports[<span class="hljs-string">"default"</span>] = y;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_classCallCheck</span>(<span class="hljs-params">instance, Constructor</span>) </span>{
  <span class="hljs-keyword">if</span> (!(instance <span class="hljs-keyword">instanceof</span> Constructor)) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">"Cannot call a class as a function"</span>);
  }
}

<span class="hljs-keyword">var</span> a = <span class="hljs-number">123</span>;
exports.a = a;
<span class="hljs-keyword">var</span> b = <span class="hljs-number">456</span>;
exports.b = b;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">c</span>(<span class="hljs-params"></span>) </span>{}

<span class="hljs-keyword">var</span> d = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">d</span>(<span class="hljs-params"></span>) </span>{
  _classCallCheck(<span class="hljs-keyword">this</span>, d);
};

exports.d = d;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">y</span>(<span class="hljs-params"></span>) </span>{}
</code></pre>
<p>由上面的代码可以看出，<code>export var b = 456</code>这样的输出方式，实际上相当于<code>var b = exports.b = 456</code>，即直接设置<code>exports</code>对象的属性来完成。而<code>export default y</code>则是设置<code>exports</code>对象的<code>default</code>属性。</p>
<p>另外，还设置了<code>exports.__esModule = true</code>来标记这是一个 ES2015 输出的模块，在通过<code>import</code>来引入模块时会判断此属性来执行相应的规则，下文将详细介绍。</p>
<p>再看看以下的 ES2015 代码：</p>
<pre><code class="language-javascript"><span class="hljs-keyword">import</span> {a, b, c, d} <span class="hljs-keyword">from</span> <span class="hljs-string">'./my_module'</span>;
<span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> mod <span class="hljs-keyword">from</span> <span class="hljs-string">'./my_module'</span>;
<span class="hljs-keyword">import</span> y <span class="hljs-keyword">from</span> <span class="hljs-string">'./my_module'</span>;

a;
mod.a;
y;
</code></pre>
<p>其编译后的 JavaScript 代码如下：</p>
<pre><code class="language-javascript"><span class="hljs-meta">'use strict'</span>;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_interopRequireDefault</span>(<span class="hljs-params">obj</span>) </span>{
  <span class="hljs-keyword">return</span> obj &amp;&amp; obj.__esModule ? obj : {
    <span class="hljs-string">'default'</span>: obj
  };
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_interopRequireWildcard</span>(<span class="hljs-params">obj</span>) </span>{
  <span class="hljs-keyword">if</span> (obj &amp;&amp; obj.__esModule) {
    <span class="hljs-keyword">return</span> obj;
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">var</span> newObj = {};
    <span class="hljs-keyword">if</span> (obj != <span class="hljs-literal">null</span>) {
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> key <span class="hljs-keyword">in</span> obj) {
        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Object</span>.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
      }
    }
    newObj[<span class="hljs-string">'default'</span>] = obj;
    <span class="hljs-keyword">return</span> newObj;
  }
}

<span class="hljs-keyword">var</span> _my_module = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./my_module'</span>);

<span class="hljs-keyword">var</span> mod = _interopRequireWildcard(_my_module);

<span class="hljs-keyword">var</span> _my_module2 = _interopRequireDefault(_my_module);

_my_module.a;
mod.a;
_my_module2[<span class="hljs-string">'default'</span>];
</code></pre>
<p>首先，<code>a</code>是通过<code>import {a} from './my_module'</code>来引入的，编译后的代码中访问<code>a</code>使用的是<code>_my_module.a</code>，而<code>_my_module = require('./my_module')</code>，所以其对应的是<code>export var a = 123</code>这样的输出。</p>
<p><code>mod</code>是通过<code>import * as mod from './my_module'</code>来引入的，其编译后的代码为<code>_interopRequireWildcard(require('./my_module'))</code>。在<code>_interopRequireWildcard()</code>函数中，如果载入的模块是由 ES2015 输出的，那么不做任何处理，否则会生成一个输入模块的拷贝，并且设置其<code>default</code>属性为自身。</p>
<p><code>y</code>是通过<code>import y from './my_module'</code>来引入的，对<code>y</code>的访问被编译成了<code>_my_module2['default']</code>，所以<code>y</code>实际上是<code>export default</code>的输出。而<code>_my_module2 = _interopRequireDefault(require('./my_module'))</code>，函数<code>_interopRequireDefault()</code>对载入的非 ES2015 模块做了处理，会返回一个<code>default</code>属性指向该模块的新对象。</p>
<p>当然模块系统的还有更复杂的语法规则，详细说明可参考：<a href="http://www.ruanyifeng.com">阮一峰</a>所著的<a href="http://es6.ruanyifeng.com/">「ECMAScript 6 入门」</a>中<a href="http://es6.ruanyifeng.com/#docs/module">「Module」</a>一章。</p>
<h3><a id="4_596"></a>4、封装模块</h3>
<p>上文例子中的<code>download()</code>函数所在的文件<code>src/index.js</code>中用到<code>randomFilename()</code>和<code>isURL()</code>这两个函数，为了使得代码结构更清晰，我们尝试把这些工具函数转移到<code>src/utils.js</code>中。</p>
<p>新建文件<code>src/utils.js</code>：</p>
<pre><code class="language-javascript"><span class="hljs-keyword">import</span> path <span class="hljs-keyword">from</span> <span class="hljs-string">'path'</span>;
<span class="hljs-keyword">import</span> os <span class="hljs-keyword">from</span> <span class="hljs-string">'os'</span>;

<span class="hljs-keyword">let</span> getTmpDir = os.tmpdir || os.tmpDir;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">randomString</span>(<span class="hljs-params">size = 6, chars = 'abcdefghijklmnopqrstuvwxyz0123456789'</span>) </span>{
  <span class="hljs-keyword">let</span> max = chars.length + <span class="hljs-number">1</span>;
  <span class="hljs-keyword">let</span> str = <span class="hljs-string">''</span>;
  <span class="hljs-keyword">while</span> (size &gt; <span class="hljs-number">0</span>) {
    str += chars.charAt(<span class="hljs-built_in">Math</span>.floor(<span class="hljs-built_in">Math</span>.random() * max));
    size--;
  }
  <span class="hljs-keyword">return</span> str;
}

<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">randomFilename</span>(<span class="hljs-params">tmpDir = getTmpDir(</span>)) </span>{
  <span class="hljs-keyword">return</span> path.resolve(tmpDir, randomString(<span class="hljs-number">20</span>));
}

<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isURL</span> (<span class="hljs-params">url</span>) </span>{
  <span class="hljs-keyword">if</span> (url.substr(<span class="hljs-number">0</span>, <span class="hljs-number">7</span>) === <span class="hljs-string">'http://'</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
  <span class="hljs-keyword">if</span> (url.substr(<span class="hljs-number">0</span>, <span class="hljs-number">8</span>) === <span class="hljs-string">'https://'</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
}

<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">noop</span>(<span class="hljs-params"></span>) </span>{ }
</code></pre>
<p>说明：<code>getTmpDir()</code>和<code>randomString()</code>仅在函数<code>randomFilename()</code>函数中用到，所以不需要使用<code>export</code>输出。</p>
<p>修改文件<code>src/index.js</code>，将相应的代码删掉，并在文件首部<code>import</code>语句后面增加以下代码：</p>
<pre><code class="language-javascript"><span class="hljs-keyword">import</span> {randomFilename, isURL, noop} <span class="hljs-keyword">from</span> <span class="hljs-string">'./utils'</span>;
</code></pre>
<h2><a id="_640"></a>单元测试</h2>
<p>本文将以<code>mocha</code>测试框架为例，单元测试程序也将使用 ES2015 来写。</p>
<p>首先执行以下命令安装<code>mocha</code>：</p>
<pre><code class="language-bash">$ npm i -g mocha
</code></pre>
<p>安装完成后可执行以下命令验证是否安装成功：</p>
<pre><code>$ mocha --version

2.3.4
</code></pre>
<p>通过阅读<code>babel</code>的官方文档（访问 <a href="http://babeljs.io/docs/setup/#mocha">http://babeljs.io/docs/setup/#mocha</a> ）可知，为了让 Node.js 中的<code>require()</code>函数能直接载入 ES2015 程序，需要依赖<code>babel-core</code>模块，执行以下命令安装：</p>
<pre><code class="language-bash">$ npm i babel-core mocha --save-dev
</code></pre>
<p>运行<code>mocha</code>命令的时候，需要增加额外的参数<code>--compilers js:babel-core/register</code>让其使用<code>babel</code>来载入 JavaScript 程序。为了方便，我们可以修改<code>package.json</code>文件，增加以下内容：</p>
<pre><code class="language-json">{
  <span class="hljs-attr">"scripts"</span>: {
    <span class="hljs-attr">"test"</span>: <span class="hljs-string">"mocha --compilers js:babel-core/register"</span>
  }
}
</code></pre>
<p>说明：我们通过<code>npm init</code>命令生成<code>package.json</code>文件时，已经自动生成了<code>test</code>命令，其默认值为<code>echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1</code>，直接将其改为<code>mocha --compilers js:babel-core/register</code>即可。</p>
<p>以上准备工作完成后，便可以开始写单元测试程序了。新建文件<code>test/test.js</code>：</p>
<pre><code class="language-javascript"><span class="hljs-keyword">import</span> assert <span class="hljs-keyword">from</span> <span class="hljs-string">'assert'</span>;
<span class="hljs-keyword">import</span> path <span class="hljs-keyword">from</span> <span class="hljs-string">'path'</span>;
<span class="hljs-keyword">import</span> fs <span class="hljs-keyword">from</span> <span class="hljs-string">'fs'</span>;
<span class="hljs-keyword">import</span> download <span class="hljs-keyword">from</span> <span class="hljs-string">'../src'</span>;
<span class="hljs-keyword">import</span> {randomFilename} <span class="hljs-keyword">from</span> <span class="hljs-string">'../src/utils'</span>;

<span class="hljs-keyword">let</span> readFile = f =&gt; fs.readFileSync(f).toString();
<span class="hljs-keyword">let</span> getFileSize = f =&gt; fs.statSync(f).size;

describe(<span class="hljs-string">'es2015_demo'</span>, () =&gt; {

  it(<span class="hljs-string">'复制本地文件成功'</span>, done =&gt; {

    <span class="hljs-keyword">let</span> source = __filename;
    <span class="hljs-keyword">let</span> target = randomFilename();
    <span class="hljs-keyword">let</span> onProgress = <span class="hljs-literal">false</span>;

    download(source, target, (size, total) =&gt; {

      onProgress = <span class="hljs-literal">true</span>;
      assert.equal(size, total);
      assert.equal(total, getFileSize(source));

    }).then(filename =&gt; {

      assert.equal(onProgress, <span class="hljs-literal">true</span>);
      assert.equal(target, filename);
      assert.equal(readFile(source), readFile(target));

      done();

    }).catch(err =&gt; {
      <span class="hljs-keyword">throw</span> err;
    });
  });

});
</code></pre>
<p>说明：本文只为了演示如何配置<code>mocha</code>和编写单元测试程序，所以没有给<code>download()</code>函数编写完整的单元测试，仅编写一个测试用例作为演示。</p>
<p>好了，现在执行<code>$ npm test</code>命令看看：</p>
<pre><code class="language-bash">$ npm <span class="hljs-built_in">test</span>

&gt; es2015_demo@1.0.0 <span class="hljs-built_in">test</span> /private/tmp/es2015_demo
&gt; mocha --compilers js:babel-core/register



  es2015_demo
    ✓ 复制本地文件成功


  1 passing (51ms)

</code></pre>
<p>至此，我们已经完成了使用 ES2015 编写模块，并使用<code>mocha</code>来进行单元测试，下文将介绍如何通过<code>babel</code>编译程序，并发布模块。</p>
<h2><a id="_741"></a>发布模块</h2>
<h3><a id="1_743"></a>1、编译</h3>
<p>上文已提到，为了让使用 ES2015 编写的代码能在 Node.js 上正常运行，需要先将其编译成 ES5 标准的代码，然后还需要在程序入口载入<code>babel-polyfill</code>模块。</p>
<p>我们可以修改文件<code>package.json</code>，为其增加<code>compile</code>命令：</p>
<pre><code class="language-json">{
  <span class="hljs-attr">"scripts"</span>: {
    <span class="hljs-attr">"compile"</span>: <span class="hljs-string">"babel -d lib/ src/"</span>
  }
}
</code></pre>
<p>说明：<code>$ babel -d lib/ src/</code>命令表示<code>lib</code>目录下的所有文件，并保存到<code>src</code>目录下。</p>
<p>配置完成后，可以执行<code>$ npm run compile</code>命令编译试试：</p>
<pre><code class="language-bash">$ npm run compile

&gt; @isnc/es2015_demo@1.0.0 compile /Users/glen/work/tmp/es2015_demo
&gt; babel <span class="hljs-_">-d</span> lib/ src/

src/copy.js -&gt; lib/copy.js
src/download.js -&gt; lib/download.js
src/index.js -&gt; lib/index.js
src/utils.js -&gt; lib/utils.js
</code></pre>
<p>此时，我们还不能直接载入<code>lib/index.js</code>文件，因为在此之前需要载入<code>babel-polyfill</code>模块。编辑文件<code>package.json</code>，设置模块入口文件：</p>
<pre><code class="language-json">{
  <span class="hljs-attr">"main"</span>: <span class="hljs-string">"index.js"</span>
}
</code></pre>
<p>说明：使用<code>$ npm init</code>生成<code>package.json</code>文件时，<code>main</code>的默认值即为<code>index.js</code>，可无需修改。</p>
<p>新建文件<code>index.js</code>：</p>
<pre><code class="language-javascript"><span class="hljs-built_in">require</span>(<span class="hljs-string">'babel-polyfill'</span>);
<span class="hljs-built_in">module</span>.exports = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./lib'</span>).default;
</code></pre>
<p>说明：在<code>src/index.js</code>中<code>download()</code>函数使用的是<code>export default</code>输出，所以在 Node.js 中需要读取模块输出的<code>default</code>属性。</p>
<p>上文中我们的测试程序是直接载入<code>src</code>目录下的程序，但模块最终发布的却是编译后的程序，为了避免因 babel 的 Bug 而导致编译后的程序与源程序功能有差异，我们的单元测试需要改用编译后的代码。</p>
<p>编辑文件<code>test/test.js</code>，将引入<code>src</code>目录的模块：</p>
<pre><code>import download from '../src';
import {randomFilename} from '../src/utils';
</code></pre>
<p>改为：</p>
<pre><code class="language-javascript"><span class="hljs-keyword">import</span> download <span class="hljs-keyword">from</span> <span class="hljs-string">'../'</span>;
<span class="hljs-keyword">import</span> {randomFilename} <span class="hljs-keyword">from</span> <span class="hljs-string">'../lib/utils'</span>;
</code></pre>
<p>在编辑<code>package.json</code>文件，将<code>test</code>命令改为先执行<code>compile</code>编译代码后再执行<code>mocha</code>测试：</p>
<pre><code>{
  &quot;scripts&quot;: {
    &quot;test&quot;: &quot;npm run compile &amp;&amp; mocha --compilers js:babel-core/register&quot;
  }
}
</code></pre>
<p>重新执行<code>$ npm test</code>可看到如下结果：</p>
<pre><code>$ npm test

&gt; es2015_demo@1.0.0 test /private/tmp/es2015_demo
&gt; npm run compile &amp;&amp; mocha --compilers js:babel-core/register


&gt; es2015_demo@1.0.0 compile /private/tmp/es2015_demo
&gt; babel -d lib/ src/

src/copy.js -&gt; lib/copy.js
src/download.js -&gt; lib/download.js
src/index.js -&gt; lib/index.js
src/utils.js -&gt; lib/utils.js


  es2015_demo
    ✓ 复制本地文件成功


  1 passing (42ms)

</code></pre>
<h3><a id="2_844"></a>2、发布</h3>
<p>在开发项目时，一般都会使用 Git 这样的源代码版本管理工具。上文例子中，<code>lib</code>目录的文件是编译生成的，可以不需要纳入到版本管理中。Node.js 项目在安装模块时会将其保存到<code>node_modules</code>目录下，这些内容也是不应该纳入版本管理的。可以添加文件<code>.gitignore</code>来将其排除：</p>
<pre><code>*.log
node_modules
lib
</code></pre>
<p>如果要将模块发布到 NPM 上，ES2015 编写的源程序也是不需要的，可以添加文件<code>.npmignore</code>来将其排除：</p>
<pre><code>src
</code></pre>
<p>在使用<code>$ npm publish</code>命令发布模块时，可以设置<code>prepublish</code>命令来让其自动执行编译。编辑文件<code>package.json</code>，增加以下内容：</p>
<pre><code class="language-json">{
  <span class="hljs-attr">"scripts"</span>: {
    <span class="hljs-attr">"prepublish"</span>: <span class="hljs-string">"npm run compile"</span>
  }
}
</code></pre>
<p>现在我们执行<code>$ npm publish</code>就可以发布模块了：</p>
<pre><code>$ npm publish

&gt; @leizongmin/es2015_demo@1.0.0 prepublish /Users/glen/work/tmp/es2015_demo
&gt; npm run compile


&gt; @leizongmin/es2015_demo@1.0.0 compile /Users/glen/work/tmp/es2015_demo
&gt; babel -d lib/ src/

src/copy.js -&gt; lib/copy.js
src/download.js -&gt; lib/download.js
src/index.js -&gt; lib/index.js
src/utils.js -&gt; lib/utils.js
+ @leizongmin/es2015_demo@1.0.0
</code></pre>
<h3><a id="3_889"></a>3、善后</h3>
<p>上文例子中需要依赖<code>mocha</code>和<code>babel</code>两个工具，当我们开发多个项目或将其作为开源项目发布出去时，可能不同的项目所依赖<code>babel</code>的版本是不一样的，为了开发环境一致，一般我们需要在当前项目中执行其开发时所指定的<code>babel</code>版本。</p>
<p>首先执行以下命令安装<code>babel-cli</code>和<code>mocha</code>：</p>
<pre><code class="language-bash">$ npm i babel-cli mocha --save-dev
</code></pre>
<p>安装完成后，对于上文中使用的<code>babel</code>和<code>mocha</code>命令，可以使用<code>./node_modules/.bin/babel</code>和<code>./node_modules/.bin/mocha</code>来执行。编辑<code>package.json</code>文件，更改<code>compile</code>和<code>test</code>命令：</p>
<pre><code class="language-json">{
  <span class="hljs-attr">"scripts"</span>: {
    <span class="hljs-attr">"compile"</span>: <span class="hljs-string">"./node_modules/.bin/babel -d lib/ src/"</span>,
    <span class="hljs-attr">"test"</span>: <span class="hljs-string">"npm run compile &amp;&amp; ./node_modules/.bin/mocha --compilers js:babel-core/register"</span>
  }
}
</code></pre>
<p>本文示例模块输出的<code>download()</code>函数使用的是 Promise 的异步模式，对于习惯使用 callback 模式的用户，我们也可以通过简单的修改来使其支持 callback 模式。</p>
<p>编辑文件<code>src/utils.js</code>，增加<code>callbackify()</code>函数：</p>
<pre><code class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">callbackify</span>(<span class="hljs-params">fn</span>) </span>{
  <span class="hljs-keyword">let</span> argc = fn.length;
  <span class="hljs-keyword">return</span> (...args) =&gt; {
    <span class="hljs-keyword">let</span> callback = args[argc];
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> callback !== <span class="hljs-string">'function'</span>) callback = <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">return</span> fn(...args)
      .then(ret =&gt; {
        callback &amp;&amp; callback(<span class="hljs-literal">null</span>, ret);
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.resolve(ret);
      })
      .catch(err =&gt; {
        callback &amp;&amp; callback(err);
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.reject(err);
      });
  }
}
</code></pre>
<p>编辑文件<code>src/index.js</code>，将其改为以下内容：</p>
<pre><code class="language-javascript"><span class="hljs-keyword">import</span> path <span class="hljs-keyword">from</span> <span class="hljs-string">'path'</span>;
<span class="hljs-keyword">import</span> mkdirp <span class="hljs-keyword">from</span> <span class="hljs-string">'mkdirp'</span>;
<span class="hljs-keyword">import</span> copyFile <span class="hljs-keyword">from</span> <span class="hljs-string">'./copy'</span>;
<span class="hljs-keyword">import</span> downloadFile <span class="hljs-keyword">from</span> <span class="hljs-string">'./download'</span>;
<span class="hljs-keyword">import</span> {randomFilename, isURL, noop, callbackify} <span class="hljs-keyword">from</span> <span class="hljs-string">'./utils'</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> callbackify(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">download</span>(<span class="hljs-params">source, target, progress</span>) </span>{
  target = target || randomFilename(download.tmpDir);
  progress = progress || noop;
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>((resolve, reject) =&gt; {

    mkdirp(path.dirname(target), err =&gt; {
      <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">return</span> callback(err);

      resolve((isURL(source) ? downloadFile : copyFile)
        (source, target, progress));
    });

  });
});
</code></pre>
<p>说明：<code>callbackify()</code>函数的作用是返回一个新的函数，这个函数可以支持原函数的 Promise 模式，同时支持 callback 模式。</p>
<p>现在再给<code>test/test.js</code>增加一个测试用例：</p>
<pre><code class="language-javascript">  it(<span class="hljs-string">'复制本地文件成功 callback'</span>, done =&gt; {

    <span class="hljs-keyword">let</span> source = __filename;
    <span class="hljs-keyword">let</span> target = randomFilename();
    <span class="hljs-keyword">let</span> onProgress = <span class="hljs-literal">false</span>;

    download(source, target, (size, total) =&gt; {

      onProgress = <span class="hljs-literal">true</span>;
      assert.equal(size, total);
      assert.equal(total, getFileSize(source));

    }, (err, filename) =&gt; {

      assert.equal(err, <span class="hljs-literal">null</span>);
      assert.equal(onProgress, <span class="hljs-literal">true</span>);
      assert.equal(target, filename);
      assert.equal(readFile(source), readFile(target));

      done();

    });
  });
</code></pre>
<p>如无意外，重新执行<code>$ npm test</code>是可以测试通过的。</p>
<h2><a id="_991"></a>后记</h2>
<p>本文的初稿在一个星期之前已经完成，一开始看到 ES2015 的新语法特性时眼前一亮，接着又觉得使用的时候有点繁琐，比如每次运行程序都有先使用 babel 编译，程序运行出错时定位的位置跟 ES2015 源码的位置不同等等。后来经过几天的摸索，发觉新的语法特性确实可以少打了很多代码，而且程序的表现力也更强了，与 babel 编译所耗的那几秒时间相比还是很值得的。</p>
<p>本文的示例代码可通过 <a href="https://github.com/leizongmin/morning.work/blob/gh-pages/demo/es2015_npm_package">https://github.com/leizongmin/morning.work/blob/gh-pages/demo/es2015_npm_package</a> 获得。</p>
<h2><a id="_998"></a>扩展阅读</h2>
<ul>
<li><a href="http://gank.io/post/564151c1f1df1210001c9161">给 JavaScript 初心者的 ES2015 实战</a></li>
<li><a href="http://es6.ruanyifeng.com/">ECMAScript 6 入门</a></li>
<li><a href="https://blog.leancloud.cn/3910/">「大概可能也许是」目前最好的 JavaScript 异步方案 async/await</a></li>
<li><a href="http://babeljs.io/docs/learn-es2015/">Learn ES2015 - A detailed overview of ECMAScript 6 features</a></li>
<li><a href="http://mammal.io/articles/using-es6-today/">Using ES6 with npm today</a></li>
<li><a href="http://jamesknelson.com/using-es6-in-the-browser-with-babel-6-and-webpack/">Using ES6 and ES7 in the Browser, with Babel 6 and Webpack</a></li>
<li><a href="http://jamesknelson.com/writing-npm-packages-with-es6-using-the-babel-6-cli/">Writing NPM packages with ES6 using the Babel 6 CLI</a></li>
<li><a href="http://info.meteor.com/blog/set-up-sublime-text-for-meteor-es6-es2015-and-jsx-syntax-and-linting">Set up Sublime Text for Meteor ES6 (ES2015) and JSX Syntax and Linting</a></li>
<li><a href="http://exploringjs.com/es6/ch_modules.html">Exploring ES6 - Modules</a></li>
</ul>
]]></description><link>http://morning.work/page/2015-11/es6-es7-develop-npm-module-using-babel.html</link><guid isPermaLink="true">http://morning.work/page/2015-11/es6-es7-develop-npm-module-using-babel.html</guid><dc:creator><![CDATA[老雷]]></dc:creator><pubDate>Mon, 30 Nov 2015 00:00:00 GMT</pubDate></item><item><title><![CDATA[Node.js 的 Buffer 那些你可能不知道的用法]]></title><description><![CDATA[<p><h3>目录</h3><ul><ul><li><a href="#_5">前言</a></li><li><a href="#_114">操作结构化数据</a></li><li><a href="#leiproto__214">lei-proto 模块介绍</a></li><li><a href="#_267">扩展阅读</a></li></ul></ul></p>
<h2><a id="_5"></a>前言</h2>
<p>在大多数介绍 Buffer 的文章中，主要是围绕数据拼接和内存分配这两方面的。比如我们使用<code>fs</code>模块来读取文件内容的时候，返回的就是一个 Buffer：</p>
<pre><code class="language-javascript">fs.readFile(<span class="hljs-string">'filename'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, buf</span>) </span>{
  <span class="hljs-comment">// &lt;Buffer 2f 2a 2a 0a 20 2a 20 53 75 ... &gt;</span>
});
</code></pre>
<p>在使用<code>net</code>或<code>http</code>模块来接收网络数据时，<code>data</code>事件的参数也是一个 Buffer，这时我们还需要使用<code>Buffer.concat()</code>来做数据拼接：</p>
<pre><code class="language-javascript"><span class="hljs-keyword">var</span> bufs = [];
conn.on(<span class="hljs-string">'data'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">buf</span>) </span>{
  bufs.push(buf);
});
conn.on(<span class="hljs-string">'end'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-comment">// 接收数据结束后，拼接所有收到的 Buffer 对象</span>
  <span class="hljs-keyword">var</span> buf = Buffer.concat(bufs);
});
</code></pre>
<p>还可以利用<code>Buffer.toString()</code>来做转换<code>base64</code>或十六进制字符的转换，比如：</p>
<pre><code class="language-javascript"><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">new</span> Buffer(<span class="hljs-string">'hello, world!'</span>).toString(<span class="hljs-string">'base64'</span>));
<span class="hljs-comment">// 转换成 base64 字符串：aGVsbG8sIHdvcmxkIQ==</span>

<span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">new</span> Buffer(<span class="hljs-string">'aGVsbG8sIHdvcmxkIQ=='</span>, <span class="hljs-string">'base64'</span>).toString());
<span class="hljs-comment">// 还原 base64 字符串：hello, world!</span>

<span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">new</span> Buffer(<span class="hljs-string">'hello, world!'</span>).toString(<span class="hljs-string">'hex'</span>));
<span class="hljs-comment">// 转换成十六进制字符串：68656c6c6f2c20776f726c6421</span>

<span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">new</span> Buffer(<span class="hljs-string">'68656c6c6f2c20776f726c6421'</span>, <span class="hljs-string">'hex'</span>).toString());
<span class="hljs-comment">// 还原十六进制字符串：hello, world!</span>
</code></pre>
<p>一般情况下，单个 Node.js 进程是有最大内存限制的，以下是来自官方文档中的说明：</p>
<blockquote>
<p><a href="https://github.com/nodejs/node-v0.x-archive/wiki/FAQ#what-is-the-memory-limit-on-a-node-process">What is the memory limit on a node process?</a></p>
<p>Currently, by default v8 has a memory limit of 512MB on 32-bit systems, and 1.4GB on 64-bit systems. The limit can be raised by setting --max_old_space_size to a maximum of ~1024 (~1 GB) (32-bit) and ~4096 (~4GB) (64-bit), but it is recommended that you split your single process into several workers if you are hitting memory limits.</p>
</blockquote>
<p>由于 Buffer 对象占用的内存空间是不计算在 Node.js 进程内存空间限制上的，因此，我们也常常会使用 Buffer 来存储需要占用大量内存的数据：</p>
<pre><code class="language-javascript"><span class="hljs-comment">// 分配一个 2G-1 字节的数据</span>
<span class="hljs-comment">// 单次分配内存超过此值会抛出异常 RangeError: Invalid typed array length</span>
<span class="hljs-keyword">var</span> buf = <span class="hljs-keyword">new</span> Buffer(<span class="hljs-number">1024</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span> - <span class="hljs-number">1</span>);
</code></pre>
<p>以上便是 Buffer 的几种常见用法。然而，阅读 Buffer 的 API 文档时，我们会发现更多的是<code>readXXX()</code>和<code>writeXXX()</code>开头的 API，具体如下：</p>
<ul>
<li>buf.readUIntLE(offset, byteLength[, noAssert])</li>
<li>buf.readUIntBE(offset, byteLength[, noAssert])</li>
<li>buf.readIntLE(offset, byteLength[, noAssert])</li>
<li>buf.readIntBE(offset, byteLength[, noAssert])</li>
<li>buf.readUInt8(offset[, noAssert])</li>
<li>buf.readUInt16LE(offset[, noAssert])</li>
<li>buf.readUInt16BE(offset[, noAssert])</li>
<li>buf.readUInt32LE(offset[, noAssert])</li>
<li>buf.readUInt32BE(offset[, noAssert])</li>
<li>buf.readInt8(offset[, noAssert])</li>
<li>buf.readInt16LE(offset[, noAssert])</li>
<li>buf.readInt16BE(offset[, noAssert])</li>
<li>buf.readInt32LE(offset[, noAssert])</li>
<li>buf.readInt32BE(offset[, noAssert])</li>
<li>buf.readFloatLE(offset[, noAssert])</li>
<li>buf.readFloatBE(offset[, noAssert])</li>
<li>buf.readDoubleLE(offset[, noAssert])</li>
<li>buf.readDoubleBE(offset[, noAssert])</li>
<li>buf.write(string[, offset][, length][, encoding])</li>
<li>buf.writeUIntLE(value, offset, byteLength[, noAssert])</li>
<li>buf.writeUIntBE(value, offset, byteLength[, noAssert])</li>
<li>buf.writeIntLE(value, offset, byteLength[, noAssert])</li>
<li>buf.writeIntBE(value, offset, byteLength[, noAssert])</li>
<li>buf.writeUInt8(value, offset[, noAssert])</li>
<li>buf.writeUInt16LE(value, offset[, noAssert])</li>
<li>buf.writeUInt16BE(value, offset[, noAssert])</li>
<li>buf.writeUInt32LE(value, offset[, noAssert])</li>
<li>buf.writeUInt32BE(value, offset[, noAssert])</li>
<li>buf.writeInt8(value, offset[, noAssert])</li>
<li>buf.writeInt16LE(value, offset[, noAssert])</li>
<li>buf.writeInt16BE(value, offset[, noAssert])</li>
<li>buf.writeInt32LE(value, offset[, noAssert])</li>
<li>buf.writeInt32BE(value, offset[, noAssert])</li>
<li>buf.writeFloatLE(value, offset[, noAssert])</li>
<li>buf.writeFloatBE(value, offset[, noAssert])</li>
<li>buf.writeDoubleLE(value, offset[, noAssert])</li>
<li>buf.writeDoubleBE(value, offset[, noAssert])</li>
</ul>
<p>这些 API 为在 Node.js 中操作数据提供了极大的便利。假设我们要将一个整形数值存储到文件中，比如当前时间戳为<code>1447656645380</code>，如果将其当作一个字符串存储时，需要占用 11 字节的空间，而将其转换为二进制存储时仅需 6 字节空间即可：</p>
<pre><code class="language-javascript"><span class="hljs-keyword">var</span> buf = <span class="hljs-keyword">new</span> Buffer(<span class="hljs-number">6</span>);

buf.writeUIntBE(<span class="hljs-number">1447656645380</span>, <span class="hljs-number">0</span>, <span class="hljs-number">6</span>);
<span class="hljs-comment">// &lt;Buffer 01 51 0f 0f 63 04&gt;</span>

buf.readUIntBE(<span class="hljs-number">0</span>, <span class="hljs-number">6</span>);
<span class="hljs-comment">// 1447656645380</span>
</code></pre>
<p>在使用 Node.js 编写一些底层功能时，比如一个网络通信模块、某个数据库的客户端模块，或者需要从文件中操作大量结构化数据时，以上 Buffer 对象提供的 API 都是必不可少的。</p>
<p>接下来将演示一个使用 Buffer 对象操作结构化数据的例子。</p>
<h2><a id="_114"></a>操作结构化数据</h2>
<p>假设有一个学生考试成绩数据库，每条记录结构如下：</p>
<table>
<thead>
<tr>
<th>学号</th>
<th>课程代码</th>
<th>分数</th>
</tr>
</thead>
<tbody>
<tr>
<td>XXXXXX</td>
<td>XXXX</td>
<td>XX</td>
</tr>
</tbody>
</table>
<p>其中学号是一个 6 位的数字，课程代码是一个 4 位数字，分数最高分为 100 分。</p>
<p>在使用文本来存储这些数据时，比如使用 CSV 格式存储可能是这样的：</p>
<pre><code>100001,1001,99
100002,1001,67
100003,1001,88
</code></pre>
<p>其中每条记录占用 15 字节的空间，而使用二进制存储时其结构将会是这样：</p>
<table>
<thead>
<tr>
<th>学号</th>
<th>课程代码</th>
<th>分数</th>
</tr>
</thead>
<tbody>
<tr>
<td>3 字节</td>
<td>2 字节</td>
<td>1 字节</td>
</tr>
</tbody>
</table>
<p>每一条记录仅需要 6 字节的空间即可，仅仅是使用文本存储的 40%！下面是用来操作这些记录的程序：</p>
<pre><code class="language-javascript"><span class="hljs-comment">// 读取一条记录</span>
<span class="hljs-comment">// buf    Buffer 对象</span>
<span class="hljs-comment">// offset 本条记录在 Buffer 对象的开始位置</span>
<span class="hljs-comment">// data   {number, lesson, score}</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">writeRecord</span> (<span class="hljs-params">buf, offset, data</span>) </span>{
  buf.writeUIntBE(data.number, offset, <span class="hljs-number">3</span>);
  buf.writeUInt16BE(data.lesson, offset + <span class="hljs-number">3</span>);
  buf.writeInt8(data.score, offset + <span class="hljs-number">5</span>);
}

<span class="hljs-comment">// 写入一条记录</span>
<span class="hljs-comment">// buf    Buffer 对象</span>
<span class="hljs-comment">// offset 本条记录在 Buffer 对象的开始位置</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">readRecord</span> (<span class="hljs-params">buf, offset</span>) </span>{
  <span class="hljs-keyword">return</span> {
    number: buf.readUIntBE(offset, <span class="hljs-number">3</span>),
    lesson: buf.readUInt16BE(offset + <span class="hljs-number">3</span>),
    score: buf.readInt8(offset + <span class="hljs-number">5</span>)
  };
}

<span class="hljs-comment">// 写入记录列表</span>
<span class="hljs-comment">// list  记录列表，每一条包含 {number, lesson, score}</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">writeList</span> (<span class="hljs-params">list</span>) </span>{
  <span class="hljs-keyword">var</span> buf = <span class="hljs-keyword">new</span> Buffer(list.length * <span class="hljs-number">6</span>);
  <span class="hljs-keyword">var</span> offset = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; list.length; i++) {
    writeRecord(buf, offset, list[i]);
    offset += <span class="hljs-number">6</span>;
  }
  <span class="hljs-keyword">return</span> buf;
}

<span class="hljs-comment">// 读取记录列表</span>
<span class="hljs-comment">// buf  Buffer 对象</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">readList</span> (<span class="hljs-params">buf</span>) </span>{
  <span class="hljs-keyword">var</span> offset = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">var</span> list = [];
  <span class="hljs-keyword">while</span> (offset &lt; buf.length) {
    list.push(readRecord(buf, offset));
    offset += <span class="hljs-number">6</span>;
  }
  <span class="hljs-keyword">return</span> list;
}
</code></pre>
<p>我们可以再编写一段程序来看看效果：</p>
<pre><code class="language-javascript"><span class="hljs-keyword">var</span> list = [
  {number: <span class="hljs-number">100001</span>, lesson: <span class="hljs-number">1001</span>, score: <span class="hljs-number">99</span>},
  {number: <span class="hljs-number">100002</span>, lesson: <span class="hljs-number">1001</span>, score: <span class="hljs-number">88</span>},
  {number: <span class="hljs-number">100003</span>, lesson: <span class="hljs-number">1001</span>, score: <span class="hljs-number">77</span>},
  {number: <span class="hljs-number">100004</span>, lesson: <span class="hljs-number">1001</span>, score: <span class="hljs-number">66</span>},
  {number: <span class="hljs-number">100005</span>, lesson: <span class="hljs-number">1001</span>, score: <span class="hljs-number">55</span>},
];
<span class="hljs-built_in">console</span>.log(list);

<span class="hljs-keyword">var</span> buf = writeList(list);
<span class="hljs-built_in">console</span>.log(buf);
<span class="hljs-comment">// 输出 &lt;Buffer 01 86 a1 03 e9 63 01 86 a2 03 e9 58 01 86 a3 03 e9 4d 01 86 a4 03 e9 42 01 86 a5 03 e9 37&gt;</span>

<span class="hljs-keyword">var</span> ret = readList(buf);
<span class="hljs-built_in">console</span>.log(ret);
<span class="hljs-comment">/* 输出
[ { number: 100001, lesson: 1001, score: 99 },
  { number: 100002, lesson: 1001, score: 88 },
  { number: 100003, lesson: 1001, score: 77 },
  { number: 100004, lesson: 1001, score: 66 },
  { number: 100005, lesson: 1001, score: 55 } ]
*/</span>
</code></pre>
<h2><a id="leiproto__214"></a>lei-proto 模块介绍</h2>
<p>上面的例子中，当每一条记录的结构有变化时，我们需要修改<code>readRecord()</code>和<code>writeRecord()</code>，重新计算每一个字段在 Buffer 中的偏移量，当记录的字段比较复杂时很容易出错。为此我编写了<code>lei-proto</code>模块，它允许你通过简单定义每条记录的结构即可生成对应的<code>readRecord()</code>和`writeRecord()函数。</p>
<p>首先执行以下命令安装此模块：</p>
<pre><code class="language-bash">$ npm install lei-proto --save
</code></pre>
<p>使用<code>lei-proto</code>模块后，前文的例子可以改为这样：</p>
<pre><code class="language-javascript"><span class="hljs-keyword">var</span> parsePorto = <span class="hljs-built_in">require</span>(<span class="hljs-string">'lei-proto'</span>);

<span class="hljs-comment">// 生成指定记录结构的数据编码/解码器</span>
<span class="hljs-keyword">var</span> record = parsePorto([
  [<span class="hljs-string">'number'</span>, <span class="hljs-string">'uint'</span>, <span class="hljs-number">3</span>],
  [<span class="hljs-string">'lesson'</span>, <span class="hljs-string">'uint'</span>, <span class="hljs-number">2</span>],
  [<span class="hljs-string">'score'</span>, <span class="hljs-string">'uint'</span>, <span class="hljs-number">1</span>]
]);

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">readList</span> (<span class="hljs-params">buf</span>) </span>{
  <span class="hljs-keyword">var</span> list = [];
  <span class="hljs-keyword">var</span> offset = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">while</span> (offset &lt; buf.length) {
    list.push(record.decode(buf.slice(offset, offset + <span class="hljs-number">6</span>)));
    offset += <span class="hljs-number">6</span>;
  }
  <span class="hljs-keyword">return</span> list;
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">writeList</span> (<span class="hljs-params">list</span>) </span>{
  <span class="hljs-keyword">return</span> Buffer.concat(list.map(record.encodeEx));
}
</code></pre>
<p>运行与上文同样的测试程序，可看到其结果是一样的：</p>
<pre><code>&lt;Buffer 01 86 a1 03 e9 63 01 86 a2 03 e9 58 01 86 a3 03 e9 4d 01 86 a4 03 e9 42 01 86 a5 03 e9 37&gt;
[ { number: 100001, lesson: 1001, score: 99 },
  { number: 100002, lesson: 1001, score: 88 },
  { number: 100003, lesson: 1001, score: 77 },
  { number: 100004, lesson: 1001, score: 66 },
  { number: 100005, lesson: 1001, score: 55 } ]
</code></pre>
<p>关于<code>lei-proto</code>模块的详细使用方法可访问该模块的主页浏览：<a href="https://github.com/leizongmin/node-lei-proto">https://github.com/leizongmin/node-lei-proto</a></p>
<p>对此感兴趣的读者也可研究一下其实现原理。</p>
<h2><a id="_267"></a>扩展阅读</h2>
<ul>
<li><a href="http://www.infoq.com/cn/articles/nodejs-about-buffer">Buffer 那些事儿</a></li>
<li><a href="https://cnodejs.org/topic/5189ff4f63e9f8a54207f60c">浅析 nodejs 的 buffer 类</a></li>
<li><a href="https://cnodejs.org/topic/4faf65852e8fb5bc65113403">小心 buffer 的拼接问题</a></li>
<li><a href="http://blog.fens.me/nodejs-buffer/">Node.js 缓冲模块 Buffer</a></li>
<li><a href="http://www.tutorialspoint.com/nodejs/nodejs_buffers.htm">Node.js - Buffers</a></li>
<li><a href="https://docs.nodejitsu.com/articles/advanced/buffers/how-to-use-buffers">How to Use Buffers in Node.js</a></li>
<li><a href="https://nodejs.org/api/buffer.html">Node.js API Documentation - Buffer</a></li>
</ul>
]]></description><link>http://morning.work/page/2015-11/nodejs_buffer.html</link><guid isPermaLink="true">http://morning.work/page/2015-11/nodejs_buffer.html</guid><dc:creator><![CDATA[老雷]]></dc:creator><pubDate>Mon, 16 Nov 2015 00:00:00 GMT</pubDate></item><item><title><![CDATA[Node.js 定制 REPL 的妙用]]></title><description><![CDATA[<p>相信在学习 Node.js 的时候，对 Node.js 的 REPL 并不陌生。我们可以在 REPL 里面输入 JavaScript 代码并立刻看到效果，常常用来试用一些新的模块，甚至直接把 REPL 当计算器来用。</p>
<p>最近在修改以前使用 Node.js 写的<a href="https://github.com/leizongmin/node-segment">中文分词模块</a>时，想要看到代码修改后的效果，但是又不方便马上写测试代码，自然想到使用 REPL 来测试。比如执行以下命令启动 Node.js 的 REPL 界面：</p>
<pre><code class="language-bash">$ node
</code></pre>
<p>然后在控制台界面中输入要测试的代码（其中<code>&gt;</code>开头的行是手工输入并按回车的代码，其他部分为 REPL 的输出结果）：</p>
<pre><code>&gt; var Segment = require('./')
undefined
&gt; var s = new Segment()
undefined
&gt; s.useDefault(); 1
1
&gt; s.doSegment('神奇的 REPL')
[ { w: '神奇的', p: 1073741824 }, { w: 'REPL', p: 16 } ]
&gt;
</code></pre>
<p>但当我修改了模块的代码后，要看效果时又要重复输入上面的代码，这种<strong>做重复无意义工作的行为绝非是一名有理想的程序员想要的</strong>。于是，我决定自己<strong>定制一个 REPL</strong>，这样就可以预先执行一些初始化代码，一启动程序就可以进入主题了。</p>
<p>看了一下<a href="https://nodejs.org/api/repl.html">REPL 模块的文档</a>之后，大概搞清了怎么个用法，接下来开始写代码了。</p>
<p>首先在项目的根目录下新建名为<code>repl</code>的文件，代码如下：</p>
<pre><code class="language-javascript"><span class="hljs-meta">#!/usr/bin/env node</span>

<span class="hljs-keyword">var</span> repl = <span class="hljs-built_in">require</span>(<span class="hljs-string">'repl'</span>);

<span class="hljs-comment">// 创建一个 REPL</span>
<span class="hljs-keyword">var</span> r = repl.start(<span class="hljs-string">'&gt; '</span>);
<span class="hljs-comment">// context 即为 REPL 中的上下文环境</span>
<span class="hljs-keyword">var</span> c = r.context;

<span class="hljs-comment">// 测试用的初始化代码</span>
<span class="hljs-comment">// 在 REPL 中可以通过 Segment 和 segment 来访问以下两个变量</span>
c.Segment = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./'</span>);
c.segment = <span class="hljs-keyword">new</span> c.Segment();
c.segment.useDefault();

<span class="hljs-comment">// 精简函数名，方便手工输入，在 REPL 中可以通过 s 来访问此函数</span>
c.s = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> c.segment.doSegment.apply(c.segment, <span class="hljs-built_in">arguments</span>);
};
</code></pre>
<p>文件第一行的<code>#!/usr/bin/env node</code>表示这是一个脚本文件，使用<code>node</code>命令来执行它，所以还要给这个文件加上可执行权限：</p>
<pre><code class="language-bash">$ chmod +x repl
</code></pre>
<p>现在就可以试试这个定制的 REPL 了：</p>
<pre><code>$ ./repl
&gt; s('神奇的 REPL')
[ { w: '神奇的', p: 1073741824 }, { w: 'REPL', p: 16 } ]
&gt;
</code></pre>
<p>之后每次更改了代码，只要按两下<code>CTRL+C</code>来退出当前 REPL，再执行<code>./repl</code>来启动程序，然后输入<code>s('神奇的 REPL')</code>就可以看到分词的效果了，如果要执行其他函数，也可以直接操作<code>segment</code>变量来做。</p>
<p><strong>但是，一名有理想的程序员绝不会满足于此的。</strong></p>
<p>当我修改了模块代码，为什么要重启 REPL 呢，难道不能重新加载一次这个模块，然后该干嘛还干嘛？</p>
<p>从<a href="https://nodejs.org/api/modules.html#modules_caching">Node.js 的模块系统文档</a>可知，在使用<code>require()</code>来加载模块后，相关的文件内容会被缓存到<code>require.cache[filename]</code>中，当再次<code>require()</code>此文件的时候并不会重新加载。所以要想在不重启进程的情况下重新加载模块，我们就要清理这个模块相关的所有缓存。</p>
<p>把<code>repl</code>文件改成以下代码：</p>
<pre><code class="language-javascript"><span class="hljs-meta">#!/usr/bin/env node</span>

<span class="hljs-keyword">var</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>);
<span class="hljs-keyword">var</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">'path'</span>);
<span class="hljs-keyword">var</span> repl = <span class="hljs-built_in">require</span>(<span class="hljs-string">'repl'</span>);


<span class="hljs-keyword">var</span> r = repl.start(<span class="hljs-string">'&gt; '</span>);
<span class="hljs-keyword">var</span> c = r.context;

<span class="hljs-comment">// 原来的初始化代码放到此函数内</span>
c._load = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
  c.Segment = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./'</span>);
  c.segment = <span class="hljs-keyword">new</span> c.Segment();
  c.segment.useDefault();
  c.s = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> c.segment.doSegment.apply(c.segment, <span class="hljs-built_in">arguments</span>);
  };
};

<span class="hljs-comment">// 在 REPL 中执行 reload()可重新加载模块</span>
c.reload = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">var</span> t = <span class="hljs-built_in">Date</span>.now();

  <span class="hljs-comment">// 清空当前项目根目录下所有文件的缓存</span>
  <span class="hljs-keyword">var</span> dir = path.resolve(__dirname) + path.sep;
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">require</span>.cache) {
    <span class="hljs-keyword">if</span> (i.indexOf(dir) === <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">delete</span> <span class="hljs-built_in">require</span>.cache[i];
    }
  }

  <span class="hljs-comment">// 重新执行初始化</span>
  c._load();
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'OK. (spent %sms)'</span>, <span class="hljs-built_in">Date</span>.now() - t);
}

c._load();
</code></pre>
<p>好了，在修改了模块的代码后，只要在 REPL 中执行<code>reload()</code>函数就能重新载入最新的代码了：</p>
<pre><code>&gt; reload()
OK. (spent 458ms)
undefined
&gt; s('神奇的 REPL')
[ { w: '神奇的', p: 1073741824 }, { w: 'REPL', p: 16 } ]
&gt;
</code></pre>
<h2><a id="_131"></a>总结</h2>
<p>本文所介绍的定制 REPL 的方法并不高深，如果在合适的场景中使用，却也能省不少事情。我目前能想到的应用场景有以下几个：</p>
<ul>
<li>开发时需要在交互界面下查看测试结果</li>
<li>在演示代码时不需要录入一系列初始化代码而快速进入演示环境</li>
<li>开发基于 Node.js 的 Shell 程序</li>
</ul>
<h2><a id="_140"></a>参考资料</h2>
<ul>
<li><a href="http://segmentfault.com/a/1190000002673137">Node.js 之 REPL</a></li>
<li><a href="http://derickbailey.com/2014/07/02/build-your-own-app-specific-repl-for-your-nodejs-app/">Build Your Own App Specific REPL For Your NodeJS App</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2015/05/command-line-with-node.html">Node.js 命令行程序开发教程</a></li>
<li><a href="https://cnodejs.org/topic/55c2ba865965fe2c74f478ac">Node.js 里的 REPL</a></li>
</ul>
]]></description><link>http://morning.work/page/2015-10/node_repl_module.html</link><guid isPermaLink="true">http://morning.work/page/2015-10/node_repl_module.html</guid><dc:creator><![CDATA[老雷]]></dc:creator><pubDate>Sat, 31 Oct 2015 00:00:00 GMT</pubDate></item><item><title><![CDATA[Node.js 项目的配置文件]]></title><description><![CDATA[<p>在使用 Node.js 编写一个完整的项目时，程序中往往需要用到一些可配置的变量，从而使得程序能在不同的环境中运行。本文将介绍几种常见的方法。</p>
<p><h3>目录</h3><ul><ul><li><a href="#_7">通过环境变量指定配置</a></li><ul><li><a href="#_42">设置环境变量</a></li><li><a href="#_Nodejs__58">在 Node.js 中读取环境变量</a></li></ul><li><a href="#_75">通过配置文件指定配置</a></li><ul><li><a href="#_124">其他配置文件格式</a></li><ul><li><a href="#JSON__141">JSON 格式</a></li><li><a href="#YAML__196">YAML 格式</a></li></ul></ul><li><a href="#_251">根据运行环境选择不同的配置</a></li><ul><li><a href="#_255">使用单一配置文件名</a></li><li><a href="#_261">通过环境变量指定配置文件名</a></li></ul><li><a href="#_config__291">使用 config 模块来读取配置</a></li><li><a href="#_394">参考资料</a></li><li><a href="#_403">相关模块</a></li></ul></ul></p>
<h2><a id="_7"></a>通过环境变量指定配置</h2>
<p><a href="http://baike.baidu.com/view/95930.htm">环境变量（environment variables）</a> 一般是指在操作系统中用来指定操作系统运行环境的一些参数，如：临时文件夹位置和系统文件夹位置等。比如<code>HOME</code>表示当前用户的根目录，<code>TMPDIR</code>表示系统临时目录等，我们可以通过设置一些特定的环境变量，程序在启动时可以读取这些环境变量并做相应的初始化动作。</p>
<p>在 Node.js 中可以通过<code>process.env</code>来访问当前的环境变量信息，比如：</p>
<pre><code class="language-javascript">{ PATH: <span class="hljs-string">'/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin'</span>,
  TMPDIR: <span class="hljs-string">'/var/folders/rs/g4wqpvvj7bj08t35dxvfm0rr0000gn/T/'</span>,
  LOGNAME: <span class="hljs-string">'glen'</span>,
  XPC_FLAGS: <span class="hljs-string">'0x0'</span>,
  HOME: <span class="hljs-string">'/Users/glen'</span>,
  TERM: <span class="hljs-string">'xterm-256color'</span>,
  COLORFGBG: <span class="hljs-string">'7;0'</span>,
  USER: <span class="hljs-string">'glen'</span>,
  ITERM_PROFILE: <span class="hljs-string">'Glen'</span>,
  TERM_PROGRAM: <span class="hljs-string">'iTerm.app'</span>,
  XPC_SERVICE_NAME: <span class="hljs-string">'0'</span>,
  SHELL: <span class="hljs-string">'/bin/zsh'</span>,
  ITERM_SESSION_ID: <span class="hljs-string">'w0t4p0'</span>,
  PWD: <span class="hljs-string">'/Users/glen/work'</span>,
  __CF_USER_TEXT_ENCODING: <span class="hljs-string">'0x1F5:0x0:0x0'</span>,
  LC_CTYPE: <span class="hljs-string">'UTF-8'</span>,
  SHLVL: <span class="hljs-string">'1'</span>,
  OLDPWD: <span class="hljs-string">'/Users/glen/work'</span>,
  ZSH: <span class="hljs-string">'/Users/glen/.oh-my-zsh'</span>,
  PAGER: <span class="hljs-string">'less'</span>,
  LESS: <span class="hljs-string">'-R'</span>,
  LSCOLORS: <span class="hljs-string">'Gxfxcxdxbxegedabagacad'</span>,
  AUTOJUMP_SOURCED: <span class="hljs-string">'1'</span>,
  AUTOJUMP_ERROR_PATH: <span class="hljs-string">'/Users/glen/Library/autojump/errors.log'</span>,
  RUST_SRC_PATH: <span class="hljs-string">'/Users/glen/work/source/rust/src'</span>,
  _: <span class="hljs-string">'/usr/local/bin/node'</span> }
</code></pre>
<h3><a id="_42"></a>设置环境变量</h3>
<p>环境变量的名字一般为大写，多个单词之间可通过下划线来连接。</p>
<p>Windows 系统下可通过<code>set</code>命令来设置环境变量，比如：</p>
<pre><code class="language-bash">$ <span class="hljs-built_in">set</span> HELLO_MSG=<span class="hljs-string">"Hello, world!"</span>
</code></pre>
<p>Linux 系统下可通过<code>export</code>命令来设置，比如：</p>
<pre><code class="language-bash">$ <span class="hljs-built_in">export</span> HELLO_MSG=<span class="hljs-string">"Hello, world!"</span>
</code></pre>
<h3><a id="_Nodejs__58"></a>在 Node.js 中读取环境变量</h3>
<p>创建文件<code>1.js</code>，代码如下：</p>
<pre><code class="language-javascript"><span class="hljs-built_in">console</span>.log(process.env.HELLO_MSG);
</code></pre>
<p>然后在命令行中执行：</p>
<pre><code class="language-bash">$ <span class="hljs-built_in">export</span> HELLO_MSG=<span class="hljs-string">"Hello, world"</span> &amp;&amp; node 1.js
</code></pre>
<p>控制台将输出<code>Hello, world</code>，即我们启动程序时给环境变量<code>HELLO_MSG</code>设置的值。</p>
<h2><a id="_75"></a>通过配置文件指定配置</h2>
<p>一些规模较小的项目往往会通过单一的配置文件来存储其配置，比如 CNode 中文社区的开源项目 <a href="https://github.com/cnodejs/nodeclub">nodeclub</a> 在启动时会载入文件<code>config.js</code>，该文件的大概结构如下：</p>
<pre><code class="language-javascript"><span class="hljs-keyword">var</span> config = {
  <span class="hljs-comment">// debug 为 true 时，用于本地调试</span>
  debug: <span class="hljs-literal">true</span>,

  name: <span class="hljs-string">'Nodeclub'</span>, <span class="hljs-comment">// 社区名字</span>
  description: <span class="hljs-string">'CNode：Node.js 专业中文社区'</span>, <span class="hljs-comment">// 社区的描述</span>
  keywords: <span class="hljs-string">'nodejs, node, express, connect, socket.io'</span>,

  <span class="hljs-comment">// 其他配置项...</span>
};
<span class="hljs-built_in">module</span>.exports = config;
</code></pre>
<p>在程序启动的时候，可以使用<code>require()</code>来载入此文件，得到一个对象，然后通过此对象的属性来读取相应的配置信息：</p>
<pre><code class="language-javascript"><span class="hljs-comment">// 载入配置文件</span>
<span class="hljs-keyword">var</span> config = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./config'</span>);

<span class="hljs-comment">// 以下为使用到配置的部分代码：</span>
<span class="hljs-keyword">if</span> (!config.debug &amp;&amp; config.oneapm_key) {
  <span class="hljs-built_in">require</span>(<span class="hljs-string">'oneapm'</span>);
}

app.use(session({
  secret: config.session_secret,
  store: <span class="hljs-keyword">new</span> RedisStore({
    port: config.redis_port,
    host: config.redis_host,
  }),
  resave: <span class="hljs-literal">true</span>,
  saveUninitialized: <span class="hljs-literal">true</span>,
}))

app.listen(config.port, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
  logger.log(<span class="hljs-string">'NodeClub listening on port'</span>, config.port);
  logger.log(<span class="hljs-string">'God bless love....'</span>);
  logger.log(<span class="hljs-string">'You can debug your app with http://'</span> + config.hostname + <span class="hljs-string">':'</span> + config.port);
  logger.log(<span class="hljs-string">''</span>);
});
</code></pre>
<p>使用配置文件与使用环境变量来指定配置相比，配置文件的可读性更强，可以表示一些更复杂的结构，而使用环境变量一般只限于<code>key=value</code>的形式。但在配置项数量较少时，使用环境变量会更简单，比如项目中只需要配置一个监听端口，可以简单使用<code>export PORT=3000 &amp;&amp; node app.js</code>命令来启动程序，而不需要单独创建一个配置文件。大多数时候往往会结合这两种方式来进行，下文讲详细讲解。</p>
<h3><a id="_124"></a>其他配置文件格式</h3>
<p>一般为了方便，在 Node.js 项目中会习惯使用<code>.js</code>文件格式，它的好处是可以使用通过程序来动态生成一些配置项，比如 nodeclub 的其中一个配置项：</p>
<pre><code class="language-javascript"><span class="hljs-keyword">var</span> config = {
  <span class="hljs-comment">// 文件上传配置</span>
  <span class="hljs-comment">// 注：如果填写 qn_access，则会上传到 7 牛，以下配置无效</span>
  upload: {
    path: path.join(__dirname, <span class="hljs-string">'public/upload/'</span>),
    url: <span class="hljs-string">'/public/upload/'</span>
  },
}
</code></pre>
<p>其中使用到了<code>path.join()</code>和<code>__dirname</code>来生成<code>upload.path</code>。</p>
<h4><a id="JSON__141"></a>JSON 格式</h4>
<p>另外，我们也可以使用 <a href="http://json.org/">JSON</a> 格式的配置文件，比如文件<code>config.json</code>：</p>
<pre><code class="language-json">{
  <span class="hljs-attr">"debug"</span>: <span class="hljs-literal">true</span>,
  <span class="hljs-attr">"name"</span>: <span class="hljs-string">"Nodeclub"</span>,
  <span class="hljs-attr">"description"</span>: <span class="hljs-string">"CNode：Node.js 专业中文社区"</span>,
  <span class="hljs-attr">"keywords"</span>: <span class="hljs-string">"nodejs, node, express, connect, socket.io"</span>
}
</code></pre>
<p>在程序中可以通过以下方式来载入 JSON 文件配置：</p>
<pre><code class="language-javascript"><span class="hljs-comment">// 通过 require()函数</span>
<span class="hljs-keyword">var</span> config = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./config.json'</span>);

<span class="hljs-comment">// 读取文件并使用 JSON.parse()解析</span>
<span class="hljs-keyword">var</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>);
<span class="hljs-keyword">var</span> config = <span class="hljs-built_in">JSON</span>.parse(fs.readFileSync(<span class="hljs-string">'./config.json'</span>).toString());
</code></pre>
<p>大多数时候，我们往往需要添加一些备注信息来说明某个配置项的使用方法及用途，在标准 JSON 文件中是不允许添加备注的，我们可以使用<code>strip-json-comments</code>模块来去掉配置文件中的备注，再将其当作标准的 JSON 来解析。</p>
<p>比如以下是带备注信息的 JSON 配置文件：</p>
<pre><code class="language-javascript">{
  <span class="hljs-comment">// debug 为 true 时，用于本地调试</span>
  <span class="hljs-string">"debug"</span>: <span class="hljs-literal">true</span>,
  <span class="hljs-comment">// 社区名字</span>
  <span class="hljs-string">"name"</span>: <span class="hljs-string">"Nodeclub"</span>,
  <span class="hljs-comment">// 社区的描述</span>
  <span class="hljs-string">"description"</span>: <span class="hljs-string">"CNode：Node.js 专业中文社区"</span>,
  <span class="hljs-string">"keywords"</span>: <span class="hljs-string">"nodejs, node, express, connect, socket.io"</span>
}
</code></pre>
<p>我们可以编写一个<code>loadJSONFile()</code>函数来载入带有备注的 JSON 文件：</p>
<pre><code class="language-javascript"><span class="hljs-keyword">var</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>);
<span class="hljs-keyword">var</span> stripJsonComments = <span class="hljs-built_in">require</span>(<span class="hljs-string">'strip-json-comments'</span>);

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">loadJSONFile</span> (<span class="hljs-params">file</span>) </span>{
  <span class="hljs-keyword">var</span> json = fs.readFileSync(file).toString();
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">JSON</span>.parse(stripJsonComments(json));
}

<span class="hljs-keyword">var</span> config = loadJSONFile(<span class="hljs-string">'./config.json'</span>);
<span class="hljs-built_in">console</span>.log(config);
</code></pre>
<h4><a id="YAML__196"></a>YAML 格式</h4>
<p><a href="http://yaml.org/">YAML</a> 是面向所有编程语言的对人类友好的数据序列化标准。其最大的优点是可读性较好，比如以下 YAML 格式的配置：</p>
<pre><code class="language-yaml"><span class="hljs-attr">name:</span> John Smith
<span class="hljs-attr">age:</span> <span class="hljs-number">37</span>
<span class="hljs-attr">spouse:</span>
<span class="hljs-attr">  name:</span> Jane Smith
<span class="hljs-attr">  age:</span> <span class="hljs-number">25</span>
<span class="hljs-attr">children:</span>
<span class="hljs-attr">  - name:</span> Jimmy Smith
<span class="hljs-attr">    age:</span> <span class="hljs-number">15</span>
<span class="hljs-attr">  - name:</span> Jenny Smith
<span class="hljs-attr">    age:</span> <span class="hljs-number">12</span>
</code></pre>
<p>其对应的 JSON 结构如下：</p>
<pre><code class="language-json">{
  <span class="hljs-attr">"age"</span>: <span class="hljs-number">37</span>,
  <span class="hljs-attr">"spouse"</span>: {
    <span class="hljs-attr">"age"</span>: <span class="hljs-number">25</span>,
    <span class="hljs-attr">"name"</span>: <span class="hljs-string">"Jane Smith"</span>
  },
  <span class="hljs-attr">"name"</span>: <span class="hljs-string">"John Smith"</span>,
  <span class="hljs-attr">"children"</span>: [
    {
      <span class="hljs-attr">"age"</span>: <span class="hljs-number">15</span>,
      <span class="hljs-attr">"name"</span>: <span class="hljs-string">"Jimmy Smith"</span>
    },
    {
      <span class="hljs-attr">"age"</span>: <span class="hljs-number">12</span>,
      <span class="hljs-attr">"name"</span>: <span class="hljs-string">"Jenny Smith"</span>
    }
  ]
}
</code></pre>
<p>在 Node.js 中可以通过<code>yamljs</code>模块来解析 YAML 格式，比如可以编写一个<code>loadYAMLFile()</code>函数来载入 YAML 格式的配置文件：</p>
<pre><code class="language-javascript"><span class="hljs-keyword">var</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>);
<span class="hljs-keyword">var</span> YAML = <span class="hljs-built_in">require</span>(<span class="hljs-string">'yamljs'</span>);

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">loadYAMLFile</span> (<span class="hljs-params">file</span>) </span>{
  <span class="hljs-keyword">return</span> YAML.parse(fs.readFileSync(file).toString());
}

<span class="hljs-keyword">var</span> config = loadYAMLFile(<span class="hljs-string">'./config.yaml'</span>);
<span class="hljs-built_in">console</span>.log(config);
</code></pre>
<h2><a id="_251"></a>根据运行环境选择不同的配置</h2>
<p>大多数情况下，程序在本地开发环境和生产环境中的配置信息是不一样的，比如开发时连接到的数据库里面的数据是模拟出来的，而生产环境要连接到实际的数据库上，因此我们需要让程序能根据不同的运行环境来载入不同的配置文件。</p>
<h3><a id="_255"></a>使用单一配置文件名</h3>
<p>以 nodeclub 项目为例，其载入的配置文件名为<code>./config.js</code>，项目中有一个默认配置文件<code>./config.default.js</code>。要运行程序，首先需要复制一份默认配置文件，并保存为<code>./config.js</code>，再根据当前运行环境来修改<code>./config.js</code>。</p>
<p>由于<code>./config.js</code>文件已经被添加到<code>.gitignore</code>文件中，因此我们<code>./config.js</code>文件的修改不会被纳入到项目的版本管理中，所以不同机器中的<code>./config.js</code>不会产生冲突，可以使用各自的配置来启动程序。</p>
<h3><a id="_261"></a>通过环境变量指定配置文件名</h3>
<p>我们可以通过环境变量来指定配置文件，比如：</p>
<pre><code class="language-bash">$ <span class="hljs-built_in">export</span> CONFIG_FILE=<span class="hljs-string">"./config/production.js"</span>
</code></pre>
<p>然后可以通过以下方式来载入配置文件：</p>
<pre><code class="language-javascript"><span class="hljs-keyword">var</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">'path'</span>);
<span class="hljs-keyword">var</span> config = <span class="hljs-built_in">require</span>(path.resolve(process.env.CONFIG_FILE));
</code></pre>
<p>另外，也可以通过环境变量来指定当前运行环境的名称，然后在指定目录下载入相应的配置，比如：</p>
<pre><code class="language-bash">$ <span class="hljs-built_in">export</span> NODE_ENV=<span class="hljs-string">"production"</span>
</code></pre>
<p>然后可以通过以下方式来载入配置文件：</p>
<pre><code class="language-javascript"><span class="hljs-keyword">var</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">'path'</span>);
<span class="hljs-keyword">var</span> configFile = path.resolve(<span class="hljs-string">'./config'</span>, process.env.NODE_ENV + <span class="hljs-string">'.js'</span>);
<span class="hljs-keyword">var</span> config = <span class="hljs-built_in">require</span>(configFile);
</code></pre>
<h2><a id="_config__291"></a>使用 config 模块来读取配置</h2>
<p><a href="https://www.npmjs.com/package/config">config</a> 模块是 NPM 上下载量最高的 Node.js 配置文件管理模块，其实现原理与上文中介绍的方法大同小异，在实际开发中我们可以考虑使用这个现成的模块。下面将介绍此模块的简单使用方法。</p>
<p><code>config</code>模块通过环境变量<code>NODE_CONFIG_DIR</code>来指定配置文件所在的目录，默认为<code>./config</code>（即当前运行目录下的<code>config</code>目录），通过环境变量<code>NODE_ENV</code>来指定当前的运行环境版本。</p>
<p>配置文件使用 JSON 格式，模块加载后，会首先载入默认的配置文件<code>${NODE_CONFIG_DIR}/default.json</code>，再载入文件<code>${NODE_CONFIG_DIR}/${NODE_ENV}.json</code>，如果配置项有冲突则覆盖默认的配置。</p>
<p>比如我们新建默认配置文件<code>config/default.json</code>：</p>
<pre><code class="language-javascript">{
  <span class="hljs-comment">// Customer module configs</span>
  <span class="hljs-string">"Customer"</span>: {
    <span class="hljs-string">"dbConfig"</span>: {
      <span class="hljs-string">"host"</span>: <span class="hljs-string">"localhost"</span>,
      <span class="hljs-string">"port"</span>: <span class="hljs-number">5984</span>,
      <span class="hljs-string">"dbName"</span>: <span class="hljs-string">"customers"</span>
    },
    <span class="hljs-string">"credit"</span>: {
      <span class="hljs-string">"initialLimit"</span>: <span class="hljs-number">100</span>,
      <span class="hljs-comment">// Set low for development</span>
      <span class="hljs-string">"initialDays"</span>: <span class="hljs-number">1</span>
    }
  }
}
</code></pre>
<p>再新建<code>production</code>环境配置文件<code>config/production.json</code>：</p>
<pre><code class="language-javascript">{
  <span class="hljs-string">"Customer"</span>: {
    <span class="hljs-string">"dbConfig"</span>: {
      <span class="hljs-string">"host"</span>: <span class="hljs-string">"prod-db-server"</span>
    },
    <span class="hljs-string">"credit"</span>: {
      <span class="hljs-string">"initialDays"</span>: <span class="hljs-number">30</span>
    }
  }
}
</code></pre>
<p>再新建测试文件<code>1.js</code>：</p>
<pre><code class="language-javascript"><span class="hljs-keyword">var</span> config = <span class="hljs-built_in">require</span>(<span class="hljs-string">'config'</span>);
<span class="hljs-built_in">console</span>.log(config);
</code></pre>
<p>执行程序，可看到其输出的结果为默认的配置：</p>
<pre><code class="language-javascript">{ Customer:
   { dbConfig: { host: <span class="hljs-string">'localhost'</span>, port: <span class="hljs-number">5984</span>, dbName: <span class="hljs-string">'customers'</span> },
     credit: { initialLimit: <span class="hljs-number">100</span>, initialDays: <span class="hljs-number">1</span> } } }
</code></pre>
<p>假如要使用<code>production</code>的配置，则使用以下命令启动：</p>
<pre><code class="language-bash">$ <span class="hljs-built_in">export</span> NODE_ENV=production &amp;&amp; node 1.js
</code></pre>
<p>则其输出将是如下结果：</p>
<pre><code class="language-json">{ Customer:
   { dbConfig: { host: 'prod-db-server', port: 5984, dbName: 'customers' },
     credit: { initialLimit: 100, initialDays: 30 } } }
</code></pre>
<p>在<code>production.json</code>文件中，重新定义了<code>Customer.dbConfig.host</code>和<code>Customer.credit.initialDays</code>这两个配置项，所以在<code>production</code>环境中仅这两项被覆盖为新的值，而其他配置项则使用<code>default.json</code>中指定的值。</p>
<p>载入<code>config</code>模块后，其返回的对象实际上就是当前的配置信息，同时提供了两个方法<code>get()</code>和<code>has()</code>来操作配置项。比如：</p>
<pre><code class="language-javascript"><span class="hljs-keyword">var</span> config = <span class="hljs-built_in">require</span>(<span class="hljs-string">'config'</span>);
<span class="hljs-built_in">console</span>.log(config);
<span class="hljs-built_in">console</span>.log(config.get(<span class="hljs-string">'Customer'</span>));
<span class="hljs-built_in">console</span>.log(config.get(<span class="hljs-string">'Customer.dbConfig'</span>));
<span class="hljs-built_in">console</span>.log(config.has(<span class="hljs-string">'Customer.dbConfig.host'</span>));
<span class="hljs-built_in">console</span>.log(config.has(<span class="hljs-string">'Customer.dbConfig.host2'</span>));
</code></pre>
<p>执行程序后输出结果如下：</p>
<pre><code>{ Customer:
   { dbConfig: { host: 'localhost', port: 5984, dbName: 'customers' },
     credit: { initialLimit: 100, initialDays: 1 } } }
{ dbConfig: { host: 'localhost', port: 5984, dbName: 'customers' },
  credit: { initialLimit: 100, initialDays: 1 } }
{ host: 'localhost', port: 5984, dbName: 'customers' }
true
false
</code></pre>
<p>其中<code>get()</code>用来获取指定配置，可以使用诸如<code>Customer.dbConfig</code>这样的格式，如果配置项不存在则会抛出异常。<code>has()</code>用来检测指定配置项是否存在，如果存在则返回<code>true</code>。</p>
<p>关于<code>config</code>模块的详细使用方法可阅读其帮助文档。</p>
<h2><a id="_394"></a>参考资料</h2>
<ul>
<li><a href="http://baike.baidu.com/view/95930.htm">百度百科：环境变量</a></li>
<li><a href="http://yijiebuyi.com/blog/1bfcf43248a873b39a3471901e764b68.html">ENV 定制开发，测试，发布环境变量</a></li>
<li><a href="http://yijiebuyi.com/blog/ad84da0f2d945dd77cf9631c8548e02c.html">node-config 模块根据 ENV 环境变量不同加载响应的配置文件</a></li>
<li><a href="http://aicode.cc/article/413.html">YAML 格式</a></li>
<li><a href="http://segmentfault.com/a/1190000000522997">.gitignore 文件使用说明</a></li>
</ul>
<h2><a id="_403"></a>相关模块</h2>
<ul>
<li><a href="https://www.npmjs.com/package/strip-json-comments">strip-json-comments</a> - 去掉 JSON 字符串中的备注</li>
<li><a href="https://www.npmjs.com/package/yamljs">yamljs</a> - 解析 YAML</li>
<li><a href="https://www.npmjs.com/package/config">config</a> - 配置文件管理</li>
</ul>
]]></description><link>http://morning.work/page/2015-09/nodejs_project_config_loader.html</link><guid isPermaLink="true">http://morning.work/page/2015-09/nodejs_project_config_loader.html</guid><dc:creator><![CDATA[老雷]]></dc:creator><pubDate>Thu, 17 Sep 2015 00:00:00 GMT</pubDate></item><item><title><![CDATA[在 Node.js 中读写大文件]]></title><description><![CDATA[<p>前段时间偶然需要整理一个几百 MB 的文本文件，内容大概 370W 行，我要将每一行的数据简单格式化一下，并转存到一个新的文件中。</p>
<p>在 Node.js 中，我们可以通过两种方式来读取文件：</p>
<ul>
<li>使用<code>fs.readFile()</code>一次性将文件内容全部读取出来，考虑到可能将来会操作几 G 大的文件，所以放弃了这种方式；</li>
<li>使用<code>fs.createReadStream()</code>创建一个读文件流，这种方式可不受限于文件的大小；</li>
</ul>
<p>因此，我很顺理成章地选用了<code>fs.createReadStream()</code>来读取文件，自然在写文件时也使用对应的<code>fs.createWriteStream()</code>来做。</p>
<p><h3>目录</h3><ul><ul><li><a href="#_15">按行读写流</a></li><ul><li><a href="#_19">安装模块</a></li><li><a href="#_27">按行读取流</a></li><li><a href="#_88">按行写流</a></li></ul><li><a href="#_127">控制读写速度</a></li><ul><li><a href="#_129">实验</a></li><li><a href="#_245">原理</a></li></ul><li><a href="#_365">优化写文件性能</a></li><ul><li><a href="#_367">实验</a></li><li><a href="#_516">原理</a></li></ul><li><a href="#_550">总结</a></li></ul></ul></p>
<h2><a id="_15"></a>按行读写流</h2>
<p>由于要操作的是文本文件，并且文件中的内容每一行记录均使用换行符<code>\n</code>来分隔，我编写了一个模块用来按行从一个<code>stream</code>中读取内容，以及按行往一个<code>stream</code>中写入内容，下面将介绍这个模块的简单使用方法。</p>
<h3><a id="_19"></a>安装模块</h3>
<p>执行以下命令安装</p>
<pre><code class="language-bash">$ npm install lei-stream --save
</code></pre>
<h3><a id="_27"></a>按行读取流</h3>
<pre><code class="language-javascript"><span class="hljs-keyword">var</span> readLine = <span class="hljs-built_in">require</span>(<span class="hljs-string">'lei-stream'</span>).readLine;

readLine(<span class="hljs-string">'./myfile.txt'</span>).go(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">data, next</span>) </span>{
  <span class="hljs-built_in">console</span>.log(data);
  next();
}, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'end'</span>);
});
</code></pre>
<p>说明：</p>
<ul>
<li><code>readLine()</code>的第一个参数应该传入一个<code>ReadStream</code>实例，当传入的是一个字符串时，会把它当作一个文件，自动调用<code>fs.createReadStream()</code>来创建一个<code>ReadStream</code></li>
<li><code>readLine()</code>的第二个参数为读取到一行内容时的回调函数，为了便于控制读取速度，需要在回调函数中执行<code>next()</code>来继续读取下一行</li>
<li><code>readLine()</code>的第三个参数为整个流读取完毕后的回调函数</li>
</ul>
<p>另外，我们也可以指定各个选项来达到更个性化的控制：</p>
<pre><code class="language-javascript"><span class="hljs-keyword">var</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>);
<span class="hljs-keyword">var</span> readLine = <span class="hljs-built_in">require</span>(<span class="hljs-string">'lei-stream'</span>).readLine;

<span class="hljs-comment">// readLineStream 第一个参数为 ReadStream 实例，也可以为文件名</span>
<span class="hljs-keyword">var</span> s = readLine(fs.createReadStream(<span class="hljs-string">'./myfile.txt'</span>), {
  <span class="hljs-comment">// 换行符，默认\n</span>
  newline: <span class="hljs-string">'\n'</span>,
  <span class="hljs-comment">// 是否自动读取下一行，默认 false</span>
  autoNext: <span class="hljs-literal">false</span>,
  <span class="hljs-comment">// 编码器，可以为函数或字符串（内置编码器：json，base64），默认 null</span>
  encoding: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">data</span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">JSON</span>.parse(data);
  }
});

<span class="hljs-comment">// 读取到一行数据时触发 data 事件</span>
s.on(<span class="hljs-string">'data'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">data</span>) </span>{
  <span class="hljs-built_in">console</span>.log(data);
  s.next();
});

<span class="hljs-comment">// 流结束时触发 end 事件</span>
s.on(<span class="hljs-string">'end'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'end'</span>);
});
</code></pre>
<p>以下是关于<code>readLine()</code>的第二个参数的说明：</p>
<ul>
<li><code>newLine</code>表示换行符，默认为<code>\n</code>，当然也可以设置为任意字符，当读取到该字符时程序会认为该行数据已结束，并触发<code>data</code>事件</li>
<li><code>autoNext</code>表示是否自动读取下一行的内容，默认为<code>false</code>，如果设置为<code>true</code>，则不需要手动执行<code>next()</code>函数来继续读取</li>
<li><code>encoding</code>为编码器函数，默认为<code>null</code>，表示不对内容编码，我们可以自己指定一个编码器（要求该函数返回的是一个字符串），这样在每次<code>write()</code>一行数据时会自动调用该函数进行预处理</li>
</ul>
<p>以下是读取数据过程中的一些说明：</p>
<ul>
<li>当读取到一行数据时，会触发<code>data</code>事件</li>
<li>调用<code>s.next()</code>来读取下一行数据，如果在初始化<code>readLine()</code>时指定了<code>autoNext=true</code>，则可省略</li>
<li>当到达流末尾时，所有数据已读取完毕，会触发<code>end</code>事件</li>
</ul>
<h3><a id="_88"></a>按行写流</h3>
<pre><code class="language-javascript"><span class="hljs-keyword">var</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>);
<span class="hljs-keyword">var</span> writeLineStream = <span class="hljs-built_in">require</span>(<span class="hljs-string">'lei-stream'</span>).writeLine;

<span class="hljs-comment">// writeLineStream 第一个参数为 ReadStream 实例，也可以为文件名</span>
<span class="hljs-keyword">var</span> s = writeLineStream(fs.createWriteStream(<span class="hljs-string">'./myfile.txt'</span>), {
  <span class="hljs-comment">// 换行符，默认\n</span>
  newline: <span class="hljs-string">'\n'</span>,
  <span class="hljs-comment">// 编码器，可以为函数或字符串（内置编码器：json，base64），默认 null</span>
  encoding: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">data</span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">JSON</span>.stringify(data);
  },
  <span class="hljs-comment">// 缓存的行数，默认为 0（表示不缓存），此选项主要用于优化写文件性能，当数量缓存的内容超过该数量时再一次性写入到流中，可以提高写速度</span>
  cacheLines: <span class="hljs-number">0</span>
});

<span class="hljs-comment">// 写一行</span>
s.write(data, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-comment">// 回调函数可选</span>
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'wrote'</span>);
});

<span class="hljs-comment">// 结束</span>
s.end(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-comment">// 回调函数可选</span>
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'end'</span>);
});
</code></pre>
<p>说明：</p>
<ul>
<li>与<code>readLine()</code>相类似，调用<code>writeLine()</code>时的第一个参数也可以是一个字符串，此时程序会自动调用<code>fs.createWriteStream()</code>来创建一个<code>WriteStream</code></li>
<li><code>writeLine()</code>的第二个参数为一些选项，其中<code>newLine</code>选项要保持与<code>readLine()</code>时 的<code>newLine</code>一致；<code>encoding</code>选项则刚好跟<code>readLine()</code>的相反；<code>cacheLines</code>选项表示缓存的数据行数，设置一个较大的值时可以一定程度提高写入性能，但也会增加写入延时，在下文将详细介绍</li>
<li>执行<code>s.write()</code>来写入一行数据</li>
<li>执行<code>s.end()</code>来结束写入</li>
</ul>
<h2><a id="_127"></a>控制读写速度</h2>
<h3><a id="_129"></a>实验</h3>
<p>我们在使用<code>fs.createReadStream()</code>创建一个读文件流后，文件内容便源源不断地被读取出来，不断地触发<code>data</code>事件。然后在<code>ReadStream</code>的<code>data</code>事件里面处理，并写入到<code>WriteStream</code>中。然而，大多数情况下读文件的速度总比写文件的速度快，这样便导致大量的数据被积压在内存中，当要读取的文件很大时，甚至会导致因占用内存太多而导致整个 Node.js 进程崩溃。</p>
<p>以下是我通过<code>lei-stream</code>编写的一个例子，按行读取数据并写入到另一个文件中（在写入文件时不等待写入完成即刻执行<code>next()</code>来读取下一行，用于模拟不限制读取速度）：</p>
<pre><code class="language-javascript"><span class="hljs-keyword">var</span> readLine = <span class="hljs-built_in">require</span>(<span class="hljs-string">'lei-stream'</span>).readLine;
<span class="hljs-keyword">var</span> writeLine = <span class="hljs-built_in">require</span>(<span class="hljs-string">'lei-stream'</span>).writeLine;

<span class="hljs-comment">// 一个几百 M 的文本文件</span>
<span class="hljs-keyword">var</span> inputFile = <span class="hljs-string">'/Volumes/Works/data/xh.txt'</span>;
<span class="hljs-keyword">var</span> outputFile = <span class="hljs-string">'/Volumes/Works/tmp/output.txt'</span>;

<span class="hljs-keyword">var</span> output = writeLine(outputFile);
<span class="hljs-keyword">var</span> counter = <span class="hljs-number">0</span>;
<span class="hljs-keyword">var</span> startTime = <span class="hljs-built_in">Date</span>.now();

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">msToS</span> (<span class="hljs-params">v</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">parseInt</span>(v / <span class="hljs-number">1000</span>, <span class="hljs-number">10</span>);
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getSpentTime</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Date</span>.now() - startTime;
}

readLine(inputFile).go(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">data, next</span>) </span>{
  counter++;
  output.write(data);
  <span class="hljs-keyword">if</span> (counter % <span class="hljs-number">10000</span> === <span class="hljs-number">0</span>) {
    printSpeedInfo();
  }
  next();
}, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'end'</span>);
  output.end(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'done. total %s lines, spent %sS'</span>, counter, msToS(getSpentTime()));
    printMemoryUsage();
    process.exit();
  });
});

<span class="hljs-comment">// 打印进度</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">printSpeedInfo</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">var</span> t = msToS(getSpentTime());
  <span class="hljs-keyword">var</span> s = counter / t;
  <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">isFinite</span>(s)) s = counter;
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'read %s lines, speed: %sL/S'</span>, counter, s.toFixed(<span class="hljs-number">0</span>));
}

<span class="hljs-comment">// 打印内存占用情况</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">printMemoryUsage</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">var</span> info = process.memoryUsage();
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mb</span> (<span class="hljs-params">v</span>) </span>{
    <span class="hljs-keyword">return</span> (v / <span class="hljs-number">1024</span> / <span class="hljs-number">1024</span>).toFixed(<span class="hljs-number">2</span>) + <span class="hljs-string">'MB'</span>;
  }
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'rss=%s, heapTotal=%s, heapUsed=%s'</span>, mb(info.rss), mb(info.heapTotal), mb(info.heapUsed));
}
setInterval(printMemoryUsage, <span class="hljs-number">1000</span>);
</code></pre>
<p>执行这个程序后，打印出来的结果如下：</p>
<pre><code>read 210000 lines, speed: 210000L/S
rss=102.86MB, heapTotal=77.64MB, heapUsed=58.09MB

...

rss=739.00MB, heapTotal=726.18MB, heapUsed=695.31MB
rss=719.15MB, heapTotal=726.18MB, heapUsed=692.25MB
rss=713.75MB, heapTotal=726.18MB, heapUsed=704.64MB
done. total 3722040 lines, spent 80S
rss=709.11MB, heapTotal=726.18MB, heapUsed=695.46MB
</code></pre>
<p>从输出的结果中可以看出，程序启动一秒后内存占用即达到<code>77.64MB</code>，而在程序结束时内存占用已达到<code>726.18MB</code>，如果文件体积再增加一倍，估计整个程序是无法执行完成的。</p>
<p>为了验证限制读取速度是否有效，我将读取内容部分的程序改为这样：</p>
<pre><code class="language-javascript">readLine(inputFile).go(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">data, next</span>) </span>{
  counter++;
  output.write(data, next);
  <span class="hljs-keyword">if</span> (counter % <span class="hljs-number">10000</span> === <span class="hljs-number">0</span>) {
    printSpeedInfo();
  }
}, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'end'</span>);
  output.end(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'done. total %s lines, spent %sS'</span>, counter, msToS(getSpentTime()));
    printMemoryUsage();
    process.exit();
  });
});
</code></pre>
<p>说明：在执行<code>output.write()</code>时，可以传入一个回调函数，当写入成功后执行此回调函数，再继续读取下一行数据。</p>
<p>重新运行程序，看到的结果如下：</p>
<pre><code>read 30000 lines, speed: 30000L/S
rss=45.11MB, heapTotal=28.18MB, heapUsed=11.11MB
read 40000 lines, speed: 40000L/S

...

read 3720000 lines, speed: 41333L/S
end
done. total 3722040 lines, spent 90S
rss=62.54MB, heapTotal=45.16MB, heapUsed=16.80MB
</code></pre>
<p>虽然程序的执行时间由原来的 80 秒增加到 90 秒，但整个进程的内存占用稳定保持在<code>45MB</code>，因此即使要读取一个超大文件功能也不会受到影响。</p>
<h3><a id="_245"></a>原理</h3>
<p><code>ReadAStream</code>提供了两个函数用于控制流：</p>
<ul>
<li><code>ReadStream.pause()</code>暂停读取 <a href="https://nodejs.org/api/stream.html#stream_readable_pause">参考文档</a></li>
<li><code>ReadStream.resume()</code>重新开始读取 <a href="https://nodejs.org/api/stream.html#stream_readable_resume">参考文档</a></li>
</ul>
<p>当读取速度超出我们期望的值时，可以执行<code>pause()</code>先暂停，待时机符合时再执行<code>resume()</code>重新开始。以下是用来限制读取速度的实例：</p>
<pre><code class="language-javascript"><span class="hljs-keyword">var</span> util = <span class="hljs-built_in">require</span>(<span class="hljs-string">'util'</span>);
<span class="hljs-keyword">var</span> events = <span class="hljs-built_in">require</span>(<span class="hljs-string">'events'</span>);
<span class="hljs-keyword">var</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>);

<span class="hljs-comment">// 一个几百 M 的文本文件</span>
<span class="hljs-keyword">var</span> inputFile = <span class="hljs-string">'/Volumes/Works/data/xh.txt'</span>;


<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ReadStreamThrottle</span> (<span class="hljs-params">stream, speed</span>) </span>{
  <span class="hljs-keyword">this</span>._stream = stream;
  <span class="hljs-keyword">this</span>._readBytes = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">this</span>._speed = speed;
  <span class="hljs-keyword">this</span>._ended = <span class="hljs-literal">false</span>;
  <span class="hljs-keyword">this</span>._readBytesSecond = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">this</span>._lastTimestamp = <span class="hljs-built_in">Date</span>.now();
  <span class="hljs-keyword">this</span>._paused = <span class="hljs-literal">false</span>;
  <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;

  <span class="hljs-comment">// 检查速度是否太快</span>
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isTooFast</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">var</span> t = (<span class="hljs-built_in">Date</span>.now() - self._lastTimestamp) / <span class="hljs-number">1000</span>;
    <span class="hljs-keyword">var</span> bps = self._readBytesSecond / t;
    <span class="hljs-keyword">return</span> bps &gt; speed;
  }

  <span class="hljs-comment">// 每隔一段时间检查速度</span>
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">checkSpeed</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">if</span> (isTooFast()) {
      self.pause();
      <span class="hljs-comment">// 直到平均速度放缓到预设的值时继续读流</span>
      <span class="hljs-keyword">var</span> tid = setInterval(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">if</span> (!isTooFast()) {
          clearInterval(tid);
          self.resume();
        }
      }, <span class="hljs-number">100</span>);
    } <span class="hljs-keyword">else</span> {
      self.resume();
    }
  }

  stream.on(<span class="hljs-string">'data'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">chunk</span>) </span>{
    self._readBytes += chunk.length;
    self._readBytesSecond += chunk.length;
    self.emit(<span class="hljs-string">'data'</span>, chunk);
    checkSpeed();
  });

  stream.on(<span class="hljs-string">'end'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    self._ended = <span class="hljs-literal">true</span>;
    self.emit(<span class="hljs-string">'end'</span>);
  });
}

util.inherits(ReadStreamThrottle, events.EventEmitter);

ReadStreamThrottle.prototype.pause = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">this</span>._paused = <span class="hljs-literal">true</span>;
  <span class="hljs-keyword">this</span>._stream.pause();
};

ReadStreamThrottle.prototype.resume = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">this</span>._paused = <span class="hljs-literal">false</span>;
  <span class="hljs-keyword">this</span>._stream.resume();
};


<span class="hljs-comment">// 读取文件，限制速度不大于 10MB/S</span>
<span class="hljs-keyword">var</span> MB = <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>;
<span class="hljs-keyword">var</span> s = <span class="hljs-keyword">new</span> ReadStreamThrottle(fs.createReadStream(inputFile), MB * <span class="hljs-number">10</span>);
<span class="hljs-keyword">var</span> bytes = <span class="hljs-number">0</span>;
<span class="hljs-keyword">var</span> t = <span class="hljs-built_in">Date</span>.now();
s.on(<span class="hljs-string">'data'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">c</span>) </span>{
  bytes += c.length;
  <span class="hljs-keyword">var</span> spent = (<span class="hljs-built_in">Date</span>.now() - t) / <span class="hljs-number">1000</span>;
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'read %s bytes, speed: %sMB/S'</span>, bytes, (bytes / MB / spent).toFixed(<span class="hljs-number">2</span>));
});
s.on(<span class="hljs-string">'end'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'end. total %s bytes'</span>, bytes);
});
</code></pre>
<p>运行程序可以看到打印出以下结果：</p>
<pre><code>read 133627904 bytes, speed: 10.00MB/S
read 133693440 bytes, speed: 10.00MB/S
read 133758976 bytes, speed: 9.92MB/S
read 133824512 bytes, speed: 9.93MB/S
read 133890048 bytes, speed: 9.93MB/S
read 133955584 bytes, speed: 9.94MB/S
read 134021120 bytes, speed: 9.94MB/S
read 134086656 bytes, speed: 9.95MB/S
read 134152192 bytes, speed: 9.95MB/S
read 134217728 bytes, speed: 9.96MB/S
read 134283264 bytes, speed: 9.96MB/S
read 134348800 bytes, speed: 9.97MB/S
read 134414336 bytes, speed: 9.97MB/S
read 134479872 bytes, speed: 9.98MB/S
read 134545408 bytes, speed: 9.98MB/S
read 134610944 bytes, speed: 9.98MB/S
read 134676480 bytes, speed: 9.99MB/S
read 134742016 bytes, speed: 9.99MB/S
end. total 134742016 bytes
</code></pre>
<p>从结果中可以看出，读取速度并不是固定的 10MB/S，而是在这个范围内不断变化。其原因是程序在读取文件时，每次都会读取一定长度的内容（比如 64KB，
这个与系统设置的缓冲区大小有关），因此我们采用一种简单的方法来控制读取速度：每次触发<code>data</code>事件时，计算每秒的读取速度，如果超过预设的值则暂停读取，并每隔 100ms 检查一次，直到平均速度在预设的范围内再重新读取。</p>
<h2><a id="_365"></a>优化写文件性能</h2>
<h3><a id="_367"></a>实验</h3>
<p>前文中提到，『大多数情况下读文件的速度总比写文件的速度快，这样便导致大量的数据被积压在内存中，当要读取的文件很大时，甚至会导致因占用内存太多而导致整个 Node.js 进程崩溃』，那为什么我们在复制超大文件时程序又没问题呢？</p>
<p>于是我编写了以下程序：</p>
<pre><code class="language-javascript"><span class="hljs-keyword">var</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>);

<span class="hljs-keyword">var</span> inputFile = <span class="hljs-string">'/Volumes/Works/data/xh.txt'</span>;
<span class="hljs-keyword">var</span> outputFile = <span class="hljs-string">'/Volumes/Works/tmp/output.txt'</span>;

<span class="hljs-keyword">var</span> input = fs.createReadStream(inputFile);
<span class="hljs-keyword">var</span> output = fs.createWriteStream(outputFile);

input.on(<span class="hljs-string">'data'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">chunk</span>) </span>{
  output.write(chunk);
});

input.on(<span class="hljs-string">'end'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'end'</span>);
  output.end(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    printMemoryUsage();
    process.exit();
  });
});

<span class="hljs-comment">// 打印内存占用情况</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">printMemoryUsage</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">var</span> info = process.memoryUsage();
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mb</span> (<span class="hljs-params">v</span>) </span>{
    <span class="hljs-keyword">return</span> (v / <span class="hljs-number">1024</span> / <span class="hljs-number">1024</span>).toFixed(<span class="hljs-number">2</span>) + <span class="hljs-string">'MB'</span>;
  }
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'rss=%s, heapTotal=%s, heapUsed=%s'</span>, mb(info.rss), mb(info.heapTotal), mb(info.heapUsed));
}
setInterval(printMemoryUsage, <span class="hljs-number">1000</span>);
</code></pre>
<p>说明：在读取文件的<code>data</code>事件中，直接将数据原样写入到另一个文件中，用于模拟简单的复制文件操作。</p>
<p>程序执行结果如下：</p>
<pre><code>rss=64.89MB, heapTotal=10.28MB, heapUsed=3.78MB
rss=82.43MB, heapTotal=11.26MB, heapUsed=3.97MB
end
rss=83.86MB, heapTotal=11.26MB, heapUsed=5.21MB
</code></pre>
<p>从结果中可以看出，在读取文件结束后，写文件操作也很快完成，而内存占用并没有太大起伏。</p>
<p>于是我将<code>data</code>事件部分改为以下代码：</p>
<pre><code class="language-javascript">input.on(<span class="hljs-string">'data'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">chunk</span>) </span>{
  chunk = chunk.toString();
  <span class="hljs-keyword">var</span> lines = chunk.split(<span class="hljs-string">'\n'</span>);
  lines.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">line</span>) </span>{
    output.write(line + <span class="hljs-string">'\n'</span>);
  });
});
</code></pre>
<p>说明：将读取出来的数据拆分成多行，并按行调用<code>write()</code>写入到文件中，用于模拟前文转换数据的例子。</p>
<p>程序运行结果如下：</p>
<pre><code>rss=117.18MB, heapTotal=91.43MB, heapUsed=62.23MB
rss=194.33MB, heapTotal=157.35MB, heapUsed=130.03MB
rss=262.67MB, heapTotal=213.45MB, heapUsed=193.70MB
rss=330.55MB, heapTotal=267.58MB, heapUsed=238.85MB
rss=408.13MB, heapTotal=329.58MB, heapUsed=300.90MB
rss=482.32MB, heapTotal=391.58MB, heapUsed=367.01MB
rss=529.28MB, heapTotal=455.54MB, heapUsed=424.50MB
rss=484.03MB, heapTotal=509.67MB, heapUsed=480.32MB
rss=460.43MB, heapTotal=565.77MB, heapUsed=539.37MB
rss=490.33MB, heapTotal=620.88MB, heapUsed=590.47MB
rss=502.39MB, heapTotal=675.99MB, heapUsed=649.05MB
rss=479.86MB, heapTotal=726.18MB, heapUsed=699.68MB
rss=829.57MB, heapTotal=734.05MB, heapUsed=698.78MB
end
rss=850.25MB, heapTotal=749.80MB, heapUsed=720.01MB
rss=851.16MB, heapTotal=749.80MB, heapUsed=720.41MB
rss=851.98MB, heapTotal=749.80MB, heapUsed=720.07MB
rss=852.92MB, heapTotal=749.80MB, heapUsed=720.56MB

...

rss=754.59MB, heapTotal=749.80MB, heapUsed=716.82MB
rss=764.16MB, heapTotal=749.80MB, heapUsed=714.73MB
rss=763.31MB, heapTotal=749.80MB, heapUsed=721.34MB
rss=762.20MB, heapTotal=749.80MB, heapUsed=725.75MB
</code></pre>
<p>由结果可以看出，在读取文件结束后，程序还运行了很长时间才完成了写文件操作，在此过程中内存占用不断地增加，并且很明显感觉到打印内存占用的速度越来越慢（本来应该是 1 秒作用的时间打印一次）。</p>
<p>是不是因为频繁的<code>write()</code>操作导致的呢？于是我又将<code>data</code>事件部分的代码改为这样：</p>
<pre><code class="language-javascript">input.on(<span class="hljs-string">'data'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">chunk</span>) </span>{
  chunk = chunk.toString();
  <span class="hljs-keyword">var</span> lines = chunk.split(<span class="hljs-string">'\n'</span>);
  output.write(lines.join(<span class="hljs-string">'\n'</span>) + <span class="hljs-string">'\n'</span>);
});
</code></pre>
<p>说明：考虑到有可能是因为<code>data</code>事件中对数据的处理导致写入缓慢，于是同样将读取出来的数据拆分成多行，但是写入时又将这些数据合并起来，只执行一次<code>write()</code>。</p>
<p>程序运行结果如下：</p>
<pre><code>rss=37.27MB, heapTotal=22.28MB, heapUsed=5.30MB
rss=78.17MB, heapTotal=39.26MB, heapUsed=14.64MB
rss=98.62MB, heapTotal=39.26MB, heapUsed=14.61MB
end
rss=100.35MB, heapTotal=39.26MB, heapUsed=15.00MB
</code></pre>
<p>由结果可以看出，在<code>data</code>事件中对数据的处理确实影响到了读文件的性能（全部读取完毕的时间由原来的 2 秒增加到 3 秒），另外内存占用也增加了，到结果与第一个例子中的简单复制文件相差不大。</p>
<p>由此可以确定，减少<code>write()</code>的次数确实能提高写文件的速度。</p>
<p>于是，在<code>lei-stream</code>模块中，增加了一个新的选项<code>cacheLines</code>用于指定缓存的行数，当执行<code>write()</code>时并不会马上将结果写入到流中，仅当达到这个数量时再一次性写入。</p>
<p>我们将『控制读写速度』章节实验例子中的<code>writeLine()</code>改为以下代码（增加<code>cacheLines</code>选项）：</p>
<pre><code>var output = writeLine(outputFile, {
  cacheLines: 10000
});
</code></pre>
<p>重新运行程序，其结果如下：</p>
<pre><code>read 3720000 lines, speed: 286154L/S
read 3720000 lines, speed: 286154L/S
read 3720000 lines, speed: 286154L/S
read 3720000 lines, speed: 286154L/S
read 3720000 lines, speed: 286154L/S
read 3720000 lines, speed: 286154L/S
end
done. total 3722040 lines, spent 13S
rss=64.83MB, heapTotal=45.16MB, heapUsed=15.29MB
</code></pre>
<p>由结果可以看出，程序执行时间从原来的 90S 下降到 13S，并且内存占用仍然保持在 45.16MB。</p>
<h3><a id="_516"></a>原理</h3>
<p>首先看看 Node.js 源码中<code>fs.ReadStream</code>的<code>write()</code>里面是怎样的（<a href="https://github.com/joyent/node/blob/master/lib/fs.js#L1789">源码</a>）：</p>
<pre><code class="language-javascript">WriteStream.prototype._write = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">data, encoding, cb</span>) </span>{
  <span class="hljs-keyword">if</span> (!util.isBuffer(data))
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.emit(<span class="hljs-string">'error'</span>, <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'Invalid data'</span>));

  <span class="hljs-keyword">if</span> (!util.isNumber(<span class="hljs-keyword">this</span>.fd))
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.once(<span class="hljs-string">'open'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">this</span>._write(data, encoding, cb);
    });

  <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;
  fs.write(<span class="hljs-keyword">this</span>.fd, data, <span class="hljs-number">0</span>, data.length, <span class="hljs-keyword">this</span>.pos, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">er, bytes</span>) </span>{
    <span class="hljs-keyword">if</span> (er) {
      self.destroy();
      <span class="hljs-keyword">return</span> cb(er);
    }
    self.bytesWritten += bytes;
    cb();
  });

  <span class="hljs-keyword">if</span> (!util.isUndefined(<span class="hljs-keyword">this</span>.pos))
    <span class="hljs-keyword">this</span>.pos += data.length;
};
</code></pre>
<p>由源码可以看出，每一次的<code>write()</code>实际上是直接调用<code>fs.write()</code>来写入文件的（<code>WriteStream</code>记录了当前文件的偏移量），当频繁调用<code>write()</code>来写入数据时，每一次都会创建用于<code>fs.write()</code>的回调函数，因此内存占用急剧升高和性能下降也就很合情合理了。</p>
<p><strong>注意：<code>lei-stream</code>本身的设计是用于读写流，并不仅限于文件流，因此<code>cacheLines</code>选项并不总是能起到提升性能的作用，所以把<code>cacheLines</code>设计为需要手动开启</strong></p>
<h2><a id="_550"></a>总结</h2>
<p>前几天在 CNode 论坛看到有人提问<a href="https://cnodejs.org/topic/55a4b5213ecc81b621bba8d0">『nodejs 如何加载大数据 json 文件比如 2g ，3g，10g』</a>，其实这里的问题除了文件很大之外，重点还是在『读取 JSON 字符串里面的某部分内容』。</p>
<p>一般情况下，在 Node.js 中读写大文件并没有什么高深的技术，主要注意以下几点：</p>
<ul>
<li>数据可被拆分成小块处理（比如一些日志文件，按行读写）</li>
<li>控制读取速度，保持读写速度同步</li>
</ul>
<p>本文中提到的<code>lei-stream</code>模块源码可从这里获得：<a href="https://github.com/leizongmin/node-lei-stream">https://github.com/leizongmin/node-lei-stream</a></p>
]]></description><link>http://morning.work/page/2015-07/read_and_write_big_file_in_nodejs.html</link><guid isPermaLink="true">http://morning.work/page/2015-07/read_and_write_big_file_in_nodejs.html</guid><dc:creator><![CDATA[老雷]]></dc:creator><pubDate>Thu, 16 Jul 2015 00:00:00 GMT</pubDate></item><item><title><![CDATA[一种简单的生产环境部署 Node.js 程序方法]]></title><description><![CDATA[<p><h3>目录</h3><ul><ul><li><a href="#_9">配置文件</a></li><li><a href="#_67">本地开发测试</a></li><li><a href="#_78">部署应用</a></li><li><a href="#_121">扩展阅读</a></li></ul></ul></p>
<p><img src="../../images/2014-08/girl.jpg" alt="我的梦想是成为一名画家"></p>
<p>最近在部署 Node.js 程序时，写了段简单的脚本，发觉还挺简单的，忍不住想与大家分享。</p>
<h2><a id="_9"></a>配置文件</h2>
<p>首先，本地测试环境和生产环境的数据库连接这些配置信息是不一样的，需要将其分开为两个文件存储
到<code>config</code>目录下，比如：</p>
<p>开发环境配置文件<code>config/development.js</code>：</p>
<pre><code class="language-javascript"><span class="hljs-built_in">module</span>.exports = {
  port:  <span class="hljs-number">3001</span>,
  mysql: {
    user: <span class="hljs-string">'root'</span>
  }
};
</code></pre>
<p>生产环境配置文件<code>config/production.js</code>:</p>
<pre><code class="language-javascript"><span class="hljs-built_in">module</span>.exports = {
  port: <span class="hljs-number">80</span>,
  mysql: {
    user: <span class="hljs-string">'myapp'</span>,
    password: <span class="hljs-string">'2zbonsjzl305vkh3'</span>
  }
};
</code></pre>
<p>另外还要建立一个程序自动载入相应环境的配置，文件<code>config/index.js</code>：</p>
<pre><code class="language-javascript"><span class="hljs-keyword">var</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">'path'</span>);

<span class="hljs-comment">// 通过 NODE_ENV 来设置环境变量，如果没有指定则默认为生产环境</span>
<span class="hljs-keyword">var</span> env = process.env.NODE_ENV || <span class="hljs-string">'production'</span>;
env = env.toLowerCase();

<span class="hljs-comment">// 载入配置文件</span>
<span class="hljs-keyword">var</span> file = path.resolve(__dirname, env);
<span class="hljs-keyword">try</span> {
  <span class="hljs-keyword">var</span> config = <span class="hljs-built_in">module</span>.exports = <span class="hljs-built_in">require</span>(file);
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Load config: [%s] %s'</span>, env, file);
} <span class="hljs-keyword">catch</span> (err) {
  <span class="hljs-built_in">console</span>.error(<span class="hljs-string">'Cannot load config: [%s] %s'</span>, env, file);
  <span class="hljs-keyword">throw</span> err;
}
</code></pre>
<p>假设应用的入口文件是<code>app.js</code>，可通过以下方法载入配置：</p>
<pre><code class="language-javascript"><span class="hljs-keyword">var</span> config = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./config'</span>);

<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'listen on port %s'</span>, config.port);
<span class="hljs-comment">// 如果是开发环境，将输出 listen on port 3001</span>
<span class="hljs-comment">// 如果是生产环境，将输出 listen on port 80</span>
</code></pre>
<h2><a id="_67"></a>本地开发测试</h2>
<p>为了方便，我新建一个脚本文件<code>run</code>，代码如下：</p>
<pre><code class="language-bash"><span class="hljs-built_in">export</span> NODE_ENV=development
node app
</code></pre>
<p>要启动程序，直接在命令行下执行<code>./run</code>即可。</p>
<h2><a id="_78"></a>部署应用</h2>
<p>新建部署脚本文件<code>deploy</code>，代码如下：</p>
<pre><code class="language-bash">git reset --hard
git pull origin HEAD
npm install
pm2 stop myapp <span class="hljs-_">-f</span>
pm2 start app.js -n myapp
</code></pre>
<p>此段代码会自动拉去 git 仓库中最新的一次提交的代码，并使用 npm 来安装 package.json 中列出的模块，
然后先停止之前已启动的应用实例，再启动。</p>
<p>为了方便传输代码到服务器端，需要将程序代码提交到一个私有的 git 仓库，首次在服务器端部署时，
需要先将代码 clone 到服务器端，比如：</p>
<pre><code class="language-bash">git <span class="hljs-built_in">clone</span> git@github.com:leizongmin/node-uc-server.git ~/myapp
</code></pre>
<p>应用在服务器端运行时使用<code>pm2</code>工具来管理进程，所以还需要先在服务器上安装此工具：</p>
<pre><code class="language-bash">npm install pm2 -g
</code></pre>
<p>完成以上准备工作后，我们就可以通过<code>deploy</code>脚本来实现自动更新代码：</p>
<ul>
<li>将本地修改提交到远程 git 仓库</li>
<li>登录服务器，进入<code>~/myapp</code>目录</li>
<li>执行<code>./deploy</code></li>
</ul>
<hr>
<p>以上程序执行的环境为 Linux，如果开发环境是 Windows，需要将<code>run</code>文件改为以下代码：</p>
<pre><code class="language-bash"><span class="hljs-built_in">set</span> NODE_ENV=development
node app
</code></pre>
<h2><a id="_121"></a>扩展阅读</h2>
<ul>
<li><a href="http://www.oschina.net/translate/goodbye-node-forever-hello-pm2">告别 node-forever,拥抱 PM2</a></li>
<li><a href="http://blog.segmentfault.com/pengedy/1190000000514886">Git 入门指引</a></li>
</ul>
]]></description><link>http://morning.work/page/2014-08/deploy-nodejs-production-app.html</link><guid isPermaLink="true">http://morning.work/page/2014-08/deploy-nodejs-production-app.html</guid><dc:creator><![CDATA[老雷]]></dc:creator><pubDate>Thu, 28 Aug 2014 00:00:00 GMT</pubDate></item><item><title><![CDATA[《Node.js 入门系列》—— 一些简单的排错方法（一）]]></title><description><![CDATA[<p><h3>目录</h3><ul><ul><li><a href="#TypeError_undefined_is_not_a_function_64">TypeError: undefined is not a function</a></li><li><a href="#TypeError_Cannot_read_property_xxx_of_undefined__TypeError_Cannot_read_property_xxx_of_null_112">TypeError: Cannot read property 'xxx' of undefined 或者 TypeError: Cannot read property 'xxx' of null</a></li><ul><li><a href="#_135">检查变量是未赋值</a></li><li><a href="#_142">检查函数是否有返回值</a></li><li><a href="#_153">检查变量是否引用了某个对象不存在的属性</a></li><li><a href="#_161">检查调用函数时是否未该传递参数</a></li></ul></ul></ul></p>
<p>俗话说“常在河边走，哪能不湿鞋”，只要动手写程序，总会时不时的冒出点问题来，
很难一下子就写出完全正确运行的程序。哪怕只是拿别人的程序来运行，也不能保证其能
适应各种各样的系统环境，不作任何修改就能使用。因此，学会一些简单的排错方法是很
有必要的。</p>
<p>在 Node.js 程序运行过程中，当出现没有被捕捉到的异常时，程序会打印出相应的出错
信息，并终止运行。比如以下出错信息：</p>
<pre><code>f:\tmp\2013-10-7\t.js:3
proceess.nextTick(function () {
^
ReferenceError: proceess is not defined
    at Object.&lt;anonymous&gt; (f:\tmp\2013-10-7\t.js:3:1)
    at Module._compile (module.js:456:26)
    at Object.Module._extensions..js (module.js:474:10)
    at Module.load (module.js:356:32)
    at Function.Module._load (module.js:312:12)
    at Function.Module.runMain (module.js:497:10)
    at startup (node.js:119:16)
    at node.js:901:3
</code></pre>
<p>出错信息的第 1 行 <code>f:\tmp\2013-10-7\t.js:3</code> 指明了在文件 <code>f:\tmp\2013-10-7\t.js</code>
的第 3 行出错了；</p>
<p>出错信息的第 2 行是相应的源程序 <code>proceess.nextTick(function () {</code> ；</p>
<p>出错信息的第 3 行的 <code>^</code> 指明了在该行的具体位置 <code>proceess</code> ；</p>
<p>出错信息的第 4 行是具体的出错信息 <code>ReferenceError: proceess is not defined</code> ，后面
还有几行以 <code>at</code> 开头的内容是详细的调用堆栈信息，可以以此来追踪到整个程序的
执行流程。</p>
<p>当遇到这样的出错信息时，我们首先应该看第 4 行的
<code>ReferenceError: proceess is not defined</code> ，前面的 <code>ReferenceError</code> 是错误对象，
表示这是一个“非法引用”错误，其后便相应的提示信息，大概意思是“ <code>proceess</code> 未定义”
（看不懂可以用软件翻译一下，比如 <a href="http://dict.youdao.com/">有道词典</a>），
这时候我们再往上看原来的程序是怎么写的：<code>proceess.nextTick(function () {</code> 。
从这个程序可以看出来，要调用的应该是 <code>process.nextTick()</code> ，
此处不小心把 <code>process</code> 写成了 <code>proceess</code> ，程序自然就报错“ <code>proceess</code> 未定义”了。</p>
<p>常见的错误对象有以下这些：</p>
<ul>
<li>
<p><strong>EvalError</strong> : 错误发生在 <code>eval()</code> 函数中，一般是要使用 <code>eval()</code> 执行的代码有语法错误</p>
</li>
<li>
<p><strong>RangeError</strong> : 数字的值超过 javascript 可表示的范围</p>
</li>
<li>
<p><strong>ReferenceError</strong> : 使用了非法的引用，一般是引用了一个未定义的变量或者函数</p>
</li>
<li>
<p><strong>SyntaxError</strong> : 在 eval()函数调用中发生了语法错误</p>
</li>
<li>
<p><strong>TypeError</strong> : 变量的类型不是预期所需的</p>
</li>
<li>
<p><strong>URIError</strong> : 在 encodeURI()或者 decodeURI()函数中发生的错误</p>
</li>
</ul>
<p>记住这些常见的错误对象有助于更快速地理解出错信息。</p>
<h2><a id="TypeError_undefined_is_not_a_function_64"></a>TypeError: undefined is not a function</h2>
<p>出现这种错误的原因是某个变量不是 <code>Function</code> 类型，却把它当函数来调用了。例如：</p>
<p>帖子： <a href="http://cnodejs.org/topic/516acc466d38277306395c93">《node 连接 mysql 出错》</a></p>
<p>Node.js 代码：</p>
<pre><code>var Client = require('mysql').Client;
var client = new Client();
client.host = 'localhost';
client.port = 3306;
client.user = 'root';
client.password = '123456';
client.database='test1';

query(client);

function query (client) {
  client.query('select * from user', function (err, res, fields) {
    console.log(res);
    client.end();
  });
}
</code></pre>
<p>出错信息：</p>
<pre><code>/home/king/node/mysql.js:2
var client = new Client();
             ^
TypeError: undefined is not a function
    at Object.&lt;anonymous&gt; (/home/king/node/mysql.js:2:14)
    at Module._compile (module.js:456:26)
    at Object.Module._extensions..js (module.js:474:10)
    at Module.load (module.js:356:32)
    at Function.Module._load (module.js:312:12)
    at Function.Module.runMain (module.js:497:10)
    at startup (node.js:119:16)
    at node.js:901:3
</code></pre>
<p>由出错信息可以看出，在执行 <code>new Client()</code> 时出错了，
<code>TypeError: undefined is not a function</code> ，也就是说，此时 <code>Client</code> 的值是
<code>undefined</code> 。我们再往上看，可以看到 <code>var Client = require('mysql').Client</code>
那么，应该是 <code>mysql</code> 这个模块并没有输出 <code>Client</code> 这个函数，我们可以执行
<code>console.log(require('mysql'))</code> 来打印 <code>mysql</code> 模块的输出，也确定并没有 <code>Client</code>
这一项，这时候就应该详细看一下 mysql 模块帮助文档以及其正确的使用方法了。</p>
<h2><a id="TypeError_Cannot_read_property_xxx_of_undefined__TypeError_Cannot_read_property_xxx_of_null_112"></a>TypeError: Cannot read property 'xxx' of undefined 或者 TypeError: Cannot read property 'xxx' of null</h2>
<p>出现这种错误的原因是尝试读取一个值为 <code>undefined</code> 或 <code>null</code> 的变量的属性。比如如下代码：</p>
<pre><code>var a = undefined;
console.log(a.b);
</code></pre>
<p>执行该程序将会抛出异常：</p>
<pre><code>TypeError: Cannot read property 'b' of undefined
    at repl:1:15
    at REPLServer.self.eval (repl.js:110:21)
    at Interface.&lt;anonymous&gt; (repl.js:239:12)
    at Interface.EventEmitter.emit (events.js:95:17)
    at Interface._onLine (readline.js:202:10)
    at Interface._line (readline.js:531:8)
    at Interface._ttyWrite (readline.js:760:14)
    at ReadStream.onkeypress (readline.js:99:10)
    at ReadStream.EventEmitter.emit (events.js:98:17)
    at emitKey (readline.js:1095:12)
</code></pre>
<p>当出现这种情况时，我们可以通过以下方法来排查：</p>
<h3><a id="_135"></a>检查变量是未赋值</h3>
<p>假如只通过 <code>var a</code> 来声明了变量，但未赋值，此时变量的值为 <code>undefined</code> ，示例：</p>
<pre><code>var a; // 没有赋值
console.log(a.b);
</code></pre>
<h3><a id="_142"></a>检查函数是否有返回值</h3>
<p>当函数没有用 <code>return</code> 来返回一个值时，那么这个函数的返回值就是 <code>undefined</code> ，
示例：</p>
<pre><code>function f () {
  // 没有返回值
}
var a = f();
console.log(a.b);
</code></pre>
<h3><a id="_153"></a>检查变量是否引用了某个对象不存在的属性</h3>
<p>当引用了某个对象一个不存在的属性时，其值就是 <code>undefined</code> ，示例：</p>
<pre><code>var obj = {};
var a = obj.c; // 引用了一个不存在的属性
console.log(a.b);
</code></pre>
<h3><a id="_161"></a>检查调用函数时是否未该传递参数</h3>
<p>当调用某个函数时没有按要求传递足够的参数，则在函数体内该参数的值是 <code>undefined</code> ，
示例：</p>
<pre><code>function f (a) {
  console.log(a.b);
}
f(); // 本来该函数需要 1 个参数
</code></pre>
<hr>
<p>扩展阅读：</p>
<ul>
<li><a href="http://www.cnblogs.com/aqbyygyyga/archive/2011/10/29/2228824.html">javascript 异常处理</a></li>
</ul>
]]></description><link>http://morning.work/page/2013-10/nodejs-simple-debug-1.html</link><guid isPermaLink="true">http://morning.work/page/2013-10/nodejs-simple-debug-1.html</guid><dc:creator><![CDATA[老雷]]></dc:creator><pubDate>Wed, 09 Oct 2013 00:00:00 GMT</pubDate></item><item><title><![CDATA[《Node.js 入门系列》—— NPM 安装第三方模块常见问题]]></title><description><![CDATA[<p><h3>目录</h3><ul><ul><li><a href="#_npm_install_xxx__5">断网的机器，没法直接 npm install xxx 怎么办？</a></li><ul><li><a href="#_github_31">模块源码没有托管到 github</a></li><li><a href="#_C__41">不需要 C++ 编译的模块还有更简便的安装方法</a></li></ul><li><a href="#_48">如何使用私有的模块</a></li><ul><li><a href="#1_NPM__50">1、搭建私有 NPM 库</a></li><li><a href="#2_js__57">2、通过一个 js 文件来链接</a></li></ul><li><a href="#npm_install__69">npm install 时出错</a></li><ul><li><a href="#_71">域名解析出错</a></li><li><a href="#_103">其他问题</a></li></ul></ul></ul></p>
<h2><a id="_npm_install_xxx__5"></a>断网的机器，没法直接 npm install xxx 怎么办？</h2>
<p>在部署 Node.js 写的应用时，我们都会在应用的根目录下执行 <code>npm install</code> 来安装所有
的依赖模块，安装第三方模块也一样，你只要找到这个模块的源码，执行 <code>npm install</code>
即可。</p>
<p>假如我们要安装一个叫 <code>xss</code> 的模块，因为不能直接用 <code>npm install xss</code> 来安装，
首先我们得想办法获取到这个这个模块的源码。</p>
<p>先在浏览器中打开模块的主页： <a href="https://npmjs.org/package/xss">https://npmjs.org/package/xss</a>
（如果不明白这个网址是怎么来的，
请阅读 <a href="http://f2e.html-js.com/article/1378">《寻找第三方模块》</a>）</p>
<p>这时候我们可以知道 xss 这个模块的源码托管在 github 上，我们可以通过 git 命令
把源码拉下来： <code>git clone git://github.com/leizongmin/js-xss.git</code></p>
<p>为了能让应用访问到这个模块，我们需要把源码放在应用的 <code>node_modules</code> 目录里面，
比如这个模块叫 <code>xss</code> ，那么它的源码就应该在 <code>node_modules/xss</code> 目录里面。</p>
<p>然后进入 <code>node_modules/xss</code> 目录，打开这个模块的 <code>package.json</code> 文件，看看
<code>dependencies</code> 这一项中是否有指定依赖模块，如果有的话，按照相同的方法把其依赖
模块也安装到这个模块的 <code>node_modules</code> 目录里。</p>
<p>（如果不明白为什么要放到 <code>node_modules</code> 目录，
请阅读 <a href="http://nodejs.org/api/modules.html#modules_loading_from_node_modules_folders">《Node.js API - Modules》</a>）</p>
<h3><a id="_github_31"></a>模块源码没有托管到 github</h3>
<p>假如某个模块没有将源码托管到 github 这样的开源平台上，我们照样有办法获取到它的
源码：把 <code>https://registry.npmjs.org/模块名/-/模块名-版本号.tgz</code> 这个压缩包下载
下来即可。</p>
<p>比如要下载 <code>xss</code> 模块 <code>0.0.6</code> 版本的源码，其对应的网址就是
<code>https://registry.npmjs.org/xss/-/xss-0.0.6.tgz</code> 。把压缩包下载下来后，先解压，
其里面的 <code>package</code> 目录即是这个模块的源码，这时候就可以按照上面说的那样安装了。</p>
<h3><a id="_C__41"></a>不需要 C++ 编译的模块还有更简便的安装方法</h3>
<p>大多数的第三方模块都是纯 JavaScript 写的，不需要进行 C++ 编译，我们只要在一台
能使用 <code>npm install xxx</code> 安装模块的机器上把模块安装好，直接复制到应用的
<code>node_modules</code> 目录即可。</p>
<h2><a id="_48"></a>如何使用私有的模块</h2>
<h3><a id="1_NPM__50"></a>1、搭建私有 NPM 库</h3>
<p>一般一些大的公司，有自己内部的 Node.js 模块库时，会尝试这种搭建私有的 NPM 库，
搭建好之后，直接使用 <code>npm install xxxx</code> 来安装模块，但是操作难度较大，有兴趣的
可以参考
<a href="https://github.com/isaacs/npmjs.org">The couchdb setup for registry.npmjs.org and search.npmjs.org</a>。</p>
<h3><a id="2_js__57"></a>2、通过一个 js 文件来链接</h3>
<p>假如有一个私有模块 <code>abc</code> ，其源码放在 <code>/npm/abc</code> 目录，我们可以直接在当前应用的
<code>node_modules</code> 目录下创建一个文件 <code>abc.js</code>，其内容如下：</p>
<pre><code>module.exports = require('/npm/abc');
</code></pre>
<p>然后就可以直接通过 <code>require('abc')</code> 来载入这个私有模块了。</p>
<p>当同时在开发几个模块，而这几个模块存在依赖关系时，使用这种方法也能方便调试。</p>
<h2><a id="npm_install__69"></a>npm install 时出错</h2>
<h3><a id="_71"></a>域名解析出错</h3>
<p>有时候网络不稳定会导致安装不成功，比如显示如下出错信息：</p>
<pre><code>npm http GET http://registry.npmjs.org/supervisor
npm ERR! Error: getaddrinfo EADDRINFO
npm ERR! at errnoException (dns.js:37:11)
npm ERR! at Object.onanswer [as oncomplete] (dns.js:124:16)
npm ERR! If you need help, you may report this log at:
npm ERR! http://github.com/isaacs/npm/issues
npm ERR! or email it to:
npm ERR! npm-@googlegroups.com

npm ERR! System Linux 3.2.0-23-generic-pae
npm ERR! command &quot;/usr/bin/node&quot; &quot;/usr/bin/npm&quot; &quot;install&quot; &quot;-g&quot; &quot;supervisor&quot;
npm ERR! cwd /home/lwj
npm ERR! node -v v0.10.18
npm ERR! npm -v 1.3.8
npm ERR! syscall getaddrinfo
npm ERR! code EADDRINFO
npm ERR! errno EADDRINFO
npm ERR!
npm ERR! Additional logging details can be found in:
npm ERR! /home/lwj/npm-debug.log
npm ERR! not ok code 0
</code></pre>
<p>从中可以找到 <code>syscall getaddrinfo</code> 和 <code>code EADDRINFO</code> 这两行，<code>EADDRINFO</code> 表示
在尝试解析域名的时候出错了，没法从 <code>registry.npmjs.org</code> 上下载模块的源码，
这时候我们只需要重新执行一遍命令即可。如果问题还没有解决，应该检查一下本地机器
域名解析服务是否正常，某些地区 <code>registry.npmjs.org</code> 这个域名会被屏蔽。如果实在
无法通过命令直接安装模块，可参考本文开头提到的方法来手动安装。</p>
<h3><a id="_103"></a>其他问题</h3>
<p>还有很多……</p>
]]></description><link>http://morning.work/page/2013-09/npm-install-problems.html</link><guid isPermaLink="true">http://morning.work/page/2013-09/npm-install-problems.html</guid><dc:creator><![CDATA[老雷]]></dc:creator><pubDate>Thu, 26 Sep 2013 00:00:00 GMT</pubDate></item><item><title><![CDATA[《Node.js 入门系列》—— 寻找第三方模块]]></title><description><![CDATA[<p><h3>目录</h3><ul><ul><li><a href="#1_5">1、知道模块名，寻找模块的文档</a></li><li><a href="#2_20">2、不知道模块名，根据关键字搜索需要的模块</a></li></ul></ul></p>
<h2><a id="1_5"></a>1、知道模块名，寻找模块的文档</h2>
<p>在看别人的代码或者文章的时候，经常会遇到自己没用过的第三方模块，怎么办呢？
其实很简单，你只要在浏览器中输入网址 <code>https://npmjs.org/package/模块名称</code> ，即可
进入这个模块的介绍页面。比如，别人的源码中出现一行 <code>var xss = require('xss')</code> ，
说明这里使用到了 <code>xss</code> 这个模块，在浏览器中打开 <code>https://npmjs.org/package/xss</code>
，即可进入这个模块在 NPM 上的主页：</p>
<p><img src="http://htmljs.b0.upaiyun.com/uploads/1380023785392-1.png" alt="xss 模块的 NPM 主页"></p>
<p>模块主页中显示这个模块的简介、作者、当前版本号、最后更新时间、模块源码链接、
报告 Bug 的链接和 README 页面。一般 README 页面都会简要地写出了模块的用途、用法
等等信息，大多数模块也都是托管在 Github 上的，直接点模块源码链接（Repository）
即可跳到其在 Github 上的主页，可以通过这里获得更多的帮助。</p>
<h2><a id="2_20"></a>2、不知道模块名，根据关键字搜索需要的模块</h2>
<p>我们可以通过 NPM 来寻找自己需要的模块。打开 NPM 的首页 <code>https://npmjs.org/</code> ，
在 Logo 的右边，有一个搜索框，只要在上面输入关键字，即可搜索出相应的模块。比如
我们要搜索“模板”相关的模块，在搜索框输入 <code>template</code> 并按回车：</p>
<p><img src="http://htmljs.b0.upaiyun.com/uploads/1380024594836-2.png" alt="NPM 搜索结果"></p>
<p>页面中显示出了相应的模块名称、简介、作者和当前版本，直接点击模块名称即可进入这个
模块的主页。</p>
<p>但是， NPM 的搜索结果中，我们没法直接看到这个模块有多少人用，最后更新时间是什么
时候了（有些模块可能已经是几年前的了），怎么办？这就要用到我压箱底多年的工具了，
一般人我不告诉他的：</p>
<p>在浏览器中打开 <code>http://eirikb.github.io/nipster/</code> （由于要加载所模块的信息，可能
要等一阵才能完全显示出来）：</p>
<p><img src="http://htmljs.b0.upaiyun.com/uploads/1380025151549-3.png" alt="Nipster 首页"></p>
<p>在搜索栏中输入关键字，会自动筛选出相应的模块。模块信息包括了模块名称、简介、
作者、最后更新时间、Fork 数量和收藏数量。默认按照 Fork 数量降序排序，基本上
最前面的结果是最多人用的。</p>
<p>上面简单介绍了两种寻找 Node.js 模块的方法，学会了这两招之后，妈妈基本上再也不用
担心你找不到好模块了。</p>
]]></description><link>http://morning.work/page/2013-09/nodejs-find-modules.html</link><guid isPermaLink="true">http://morning.work/page/2013-09/nodejs-find-modules.html</guid><dc:creator><![CDATA[老雷]]></dc:creator><pubDate>Tue, 24 Sep 2013 00:00:00 GMT</pubDate></item></channel></rss>